
[[datenhaltung]]
= Datenhaltung

In diesem Kapitel wird die Implementierung der Datenhaltung einer Anwendung beschrieben.
Die Datenhaltung besteht im Wesentlichen aus den Entitätsklassen und den zugehörigen Data Access Objects (DAOs).

[[designvorgaben]]
== Designvorgaben

* Der eigentliche Datenbankzugriff wird über Java Persistence API (JPA) gekapselt.
Als Implementierung für die JPA wird Hibernate verwendet.
* Das Datenbank-Mapping wird über Annotation in den Entitätsklassen festgelegt.
* Der Zugriff auf Entitäten erfolgt immer über DAOs oder durch die Traversierung des persistenten Datenmodells.
* DAOs stellen Zugriffsmethoden (Suchen, Schreiben, Löschen...) für genau einen Entitätstyp bereit.
* Datenbank-Queries werden nach Möglichkeit als Named Queries abgelegt.
* Entitäten werden entweder von genau einer fachlichen Komponente oder querschnittlich von der Komponente „Basisdaten“ verwaltet.
* Der Datenzugriff erfolgt entweder über die Komponenten-Schnittstelle oder im Fall der Basisdaten direkt über die Basisdaten-DAOs.
* Für persistente Entitäten, die über eine Komponentenschnittstelle angeboten werden, werden eigene Schnittstellenobjekte definiert, die
per Deep-Copy gefüllt werden. Hierfür wird der Bean-Mapper Dozer verwendet.
Innerhalb einer Teilanwendung dürfen persistente Entitäten allerdings über Komponentengrenzen hinweg genutzt werden.
* Die Transaktionssteuerung wird per AOP in der Service-Schicht durchgeführt (siehe Kapitel <<anbieten-von-service-schnittstellen>>).
+
NOTE: Aspect-Oriented Programming (AOP) ist ein Programmierparadigma, das anstrebt, verschiedene logische Aspekte eines Programmes getrennt voneinander zu entwerfen, zu
entwickeln und zu testen. Die getrennt entwickelten Aspekte werden dann zur endgültigen Anwendung zusammengefügt.
* Der Primärschlüssel einer Entität besteht aus genau einem Attribut.
Besteht der fachliche Schlüssel der Entität aus genau einem Attribut, so wird er auch als Primärschlüssel verwendet.
Ansonsten wird ein künstlicher technischer Primärschlüssel verwendet.

[[packagestruktur]]
== Packagestruktur

* Die DAOs- und Entitätsklassen werden im Persistence-Package der entsprechenden Komponente implementiert.
* Für DAOs ist dies +
`<organisation>.<domäne>.<system>.persistence.<komponente>.dao.impl`. +
Dazu wird für jedes DAO ein Interface in +
 `<organisation>.<domäne>.<system>.persistence.<komponente>.dao` +
 angelegt
+
NOTE: Für das Bundesverwaltungsamt ist dies z.B. `de.bund.bva`

* Entitäten werden in +
`<organisation>.<domäne>.<system>.persistence.<komponente>.entity` +
implementiert
* Die Schnittstellen-Klassen sind Teil der Schnittstelle der zugehörigen Komponente und werden daher im Package der entsprechenden
Komponente implementiert: `<organisation>.<domäne>.<system>.core.<komponente>.ausgabedaten`

[[klassendesign]]
== Klassendesign

:desc-image-Datenhaltung: Klassendesign für die Datenhaltung
[id="image-Datenhaltung",reftext="{figure-caption} {counter:figures}"]
.{desc-image-Datenhaltung}
image::Datenhaltung.png[align="center"]


:desc-table-Datenhaltung: Klassenbeschreibung für die Datenhaltung
[id="table-Datenhaltung",reftext="{table-caption} {counter:tables}"]
.{desc-table-Datenhaltung}
[cols="2,3"]
|====
|*AuskunftImpl* |AuskunftImpl ist die Implementierung der Komponente Auskunft (Anwendungskern). Die Komponente verwendet die DAOs zum  Zugriff auf ihre Daten.
Während die DAOs die eigentlichen Entitätstypen anbieten, liefert die Komponente Auskunft nur nicht persistente Schnittstellenobjekte auf ihre Daten.
|*RegisterEintragDao* |DAOs kapseln den Datenbankzugriff für spezifische Entitätstypen.
Sie stellen Methoden zum Suchen, Anlegen und Löschen dieser Typen zur Verfügung.
Zur Durchführung der Datenbank-Queries benötigt das DAO den EntityManager.
Dieser wird von Spring bereitgestellt.
|*RegisterEintrag* |Implementierungsklasse für Entitäten vom Typ „RegisterEintrag“. Enthält Getter- und Setter-Methoden für alle Attribute.
|*RegisterEintragDaten* |Nicht persistentes Schnittstellenobjekt, das die Daten des RegisterEintrags enthält.
Wird als Deep-Copy durch Bean-Mapper erzeugt.
|====

Im Normalfall verwenden Komponenten die Daten anderer Komponenten über deren Schnittstelle.
Der direkte Zugriff auf die DAOs ist verboten.

Entitäten, die von mehreren Anwendungskomponenten verwendet werden, werden von der "Komponente" Basisdaten angeboten.
Die Komponente Basisdaten ist keine vollständige Komponente, sie bietet keine Schnittstelle an.
Ausnahmsweise verwenden Komponenten stattdessen direkt die zugehörigen DAOs der Basisdaten.
Dieser Fall ist auch in <<image-Datenhaltung>> dargestellt.
Weitere Details können <<IsyFactReferenzarchitektur>> entnommen werden.

[[realisierung]]
== Realisierung

Zur Realisierung der Datenhaltung müssen folgende Aktivitäten durchgeführt werden.

[[anlegen-des-datenbankschemas]]
=== Anlegen des Datenbankschemas

Das Datenbankschema muss angelegt werden.
Dazu werden die benötigten DDL-Anweisungen, wie im <<DatenzugriffDetailkonzept>> beschrieben, in einem Verzeichnis abgelegt.
Die <<Vorlageanwendung>> enthält diese Anweisungen im Verzeichnis `src/main/skripte/sql/terminfindung`.

Das initiale Datenmodell kann über das Tool hbm2ddl erzeugt werden.
Dieses muss anschließend noch bearbeitet werden.

NOTE: hbm2ddl ist Teil der Hibernate Tools und gehört zum Umfang der Standard-Hibernate Bibliothek.
Nutzungsdokumentation unter:
http://docs.jboss.org/hibernate/core/3.2/reference/en/html/toolsetguide.html%23toolsetguide-s1-5[http://docs.jboss.org/hibernate/core/3.2/reference/en/html/toolsetguide.html#toolsetguide-s1-5]

[[einbinden-der-bibliotheken]]
=== Einbinden der Bibliotheken

Die benötigten Bibliotheken müssen als Abhängigkeiten in die Maven-Konfiguration (`pom.xml`) aufgenommen werden.
Eine passende Beispielkonfiguration findet sich in der Maven-Konfiguration der <<Vorlageanwendung>>.

[[implementierung-der-entitätsklassen-und-daos]]
=== Implementierung der Entitätsklassen und DAOs

Die DAOs, Entitäts-Klassen und Schnittstellen-Klassen müssen implementiert werden.
In den Entitätsklassen müssen die Mapping-Informationen für JPA als Annotations eingetragen werden.

Die Named Queries für die DAOs werden in der Konfigurationsdatei `NamedQueries.hbm.xml` (siehe nächstes Kapitel) abgelegt.
Die DAOs verwenden einen Schlüssel zur Identifikation einer Query.
Für jeden Schlüssel wird eine Konstante in einer Konstantenklasse (z.B. `DatenbankKonstanten`) angelegt.

[[anlegen-der-konfigurationsdateien]]
=== Anlegen der Konfigurationsdateien

Die in <<table-DatenhaltungCFG>> genannten Konfigurationsdateien müssen angelegt werden.
Details dazu können <<DatenzugriffDetailkonzept>> entnommen werden.
Entsprechende Beispieldateien finden sich in der <<Vorlageanwendung>>.

:desc-table-DatenhaltungCFG: Konfigurationsdateien für die Datenhaltung
[id="table-DatenhaltungCFG",reftext="{table-caption} {counter:tables}"]
.{desc-table-DatenhaltungCFG}
[cols="3,2,1",options="header"]
|====
|Pfad |Datei |Beschreibung
|`src/main/resources/config` | `jpa.properties` |Konfiguration der Datenbank-Verbindung
|`src/main/resources/spring/persistence` | `dao.xml` |Spring Konfiguration für JPA
|`src/main/resources` | `Named-Queries.hbm.xml` |Named Queries für DAOs
|`src/main/resources/META-INF` | `persistence.xml` |JPA-Konfiguration
|====

[[implementierung-von-schnittstellen-klassen]]
=== Implementierung von Schnittstellen-Klassen

Schnittstellen-Klassen dienen als eine nur Lese-Sicht auf persistente Entitäten.
Dieses wird benötigt, wenn Komponenten persistente Entitäten über ihre Schnittstelle herausgeben, um zu verhindern, dass andere Komponenten diese Daten ändern.

Schnittstellen-Klassen enthalten alle Attribute, die auch ihre persistenten Gegenstücke besitzen.
Zusätzlich besitzen sie Getter-/Settermethoden für alle Attribute.

Die Schnittstellen-Objekte werden per Deep-Copy mittels des Bean-Mappers Dozer erzeugt und dem Aufrufer außerhalb der Teilanwendung zurückgeliefert.
So stehen dem Aufrufer alle Informationen zur Verfügung, es ist ihm aber nicht möglich, Änderungen zu persistieren.
Damit ist die Datenhoheit der Komponente gewahrt.

Im Folgenden ist ein beispielhaftes Mapping zu sehen:

:desc-listing-beanmapper: Beispielhaftes Bean-Mapping
[id="listing-beanmapper",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-beanmapper}
[source,java]
----
/** Dozer Bean-Mapper. */
protected Mapper mapper;
// Entität mappen
RegisterEintragDaten daten = mapper.map(registerEintrag, RegisterEintragDaten.class);
----

[[fachkomponenten-der-anwendung]]
= Fachkomponenten der Anwendung

In diesem Kapitel wird die Realisierung von Fachkomponenten beschrieben.

[[designvorgaben-1]]
== Designvorgaben

* Alle Komponenten definieren ihre Schnittstelle über ein Java-Interface.
Eine Ausnahme bildet die Komponente Basisdaten.
Diese Komponente verwaltet gemeinsam genutzte Daten und bietet keine eigene Schnittstelle an.
Der Zugriff erfolgt hier direkt über die DAOs (siehe Kapitel <<klassendesign>>).
* Komponenten bieten an ihrer Schnittstelle eine Nur-Lese-Sicht auf ihre Daten an.
Für jeden Entitätstyp wird eine nicht-persistente Schnittstellenklasse erstellt.
Das Komponenten Interface wird von einer Java-Klasse implementiert.
Diese Klasse kann die Anwendungsfälle im einfachen Fall direkt implementieren oder an Anwendungsfall-Klassen delegieren.
* Die interne Strukturierung von Komponenten ist nicht im Detail vorgeben.
Für fachliche Komponenten wird eine Basisimplementierung in <<IsyFactReferenzarchitektur>> beschrieben.

[[klassendesign-1]]
== Klassendesign

:desc-image-Fachliche_Komponente:  Klassendesign für Fachkomponenten
[id="image-Fachliche_Komponente",reftext="{figure-caption} {counter:figures}"]
.{desc-image-Fachliche_Komponente}
image::Fachliche_Komponente.png[align="center"]

:desc-table-Datenhaltung1: Klassenbeschreibung für Komponenten Datenhaltung
[id="table-Datenhaltung1",reftext="{table-caption} {counter:tables}"]
.{desc-table-Datenhaltung1}
[cols="2,3"]
|====
|*Auskunft*
a| Interfaces zur Definitionen der Schnittstelle der Komponente "Auskunft". +
Zu beachten ist, dass über die Schnittstelle keine Entitäten der Komponente herausgegeben werden.
Es darf immer nur eine Nur-Lese-Sicht (nicht-persistente Schnittstellen-Objekte) herausgegeben werden. +
Die Umwandlung der internen (`RegisterEintrag`) auf die externe Sicht erfolgt per Bean-Mapper Dozer.
|*AuskunftImpl* |Implementierung der Komponente „Auskunft“. Diese Klasse wird als Spring-Bean konfiguriert.
Weitere benötigte Komponenten (Spring-Beans) werden dieser Komponente per Spring-Dependency-Injection bekannt gemacht.
Alle weiteren Klassen der Komponente, z.B. AWF-Klassen werden in der `AuskunftImpl` "normal" instanziiert, und die benötigten Referenzen übergeben.
|*AwfLeseGesamtBestand* |Beispielklasse zur Implementierung eines Anwendungsfalls.
Diese Klassen werden explizit instanziiert, also nicht als Spring-Bean konfiguriert.
Falls ein Anwendungsfall weitere Komponenten (Konfiguration, Regelwerk) etc. benötigt, werden diese durch die instanziierende Impl-Klasse übergeben.
|*RegisterEintrag* |Persistente Entität für Register-Einträge.
|*RegisterEintragDaten* |Nur-Lese-Sicht auf Register-Einträge (siehe Kapitel <<implementierung-von-schnittstellen-klassen>>).
|====

[[package-struktur]]
== Package-Struktur

* Die Realisierung der Komponenten-Schnittstelle erfolgt im Package +
  `<organisation>.<domäne>.<system>.core.<komponente>`
+
NOTE: Für das Bundesverwaltungsamt ist dies z.B. `de.bund.bva`
+
* Die Realisierung der Komponenten-Implementierung erfolgt im Package +
  `<organisation>.<domäne>.<system>.core.<komponente>.impl.*`
* Die nicht-persistenten Schnittstellen-Klassen werden im Package +
  `<organisation>.<domäne>.<system>.core.<komponente>.ausgabedaten.*` +
  implementiert.

[[realisierung-1]]
== Realisierung

* Die Implementierungsklassen und Interfaces der Komponente werden implementiert.
* Die Komponente wird als Spring-Bean in der Spring-Konfiguration `src/main/resources/resources/spring/komponenten.xml` konfiguriert.
* Je nach Bedarf wird die Komponente anderen Komponenten per Dependency-Injection bekannt gemacht.

[[anwendungsnutzung]]
= Anwendungsnutzung

In diesem Kapitel wird die Realisierung von verschiedenen, technischen Zugangswegen zum Anwendungskern beschrieben, mit Ausnahme des GUI-Zugangs.
Das Thema umfasst das Anbieten von internen Service-Schnittstellen per HttpInvoker, das Nutzen derselben und die Nutzung des Anwendungskerns im
Rahmen der Batch-Verarbeitung.

:desc-image-RAIT:  Referenzarchitektur eines IT-Systems
[id="image-RAIT",reftext="{figure-caption} {counter:figures}"]
.{desc-image-RAIT}
image::RAIT.png[align="center"]

[[anbieten-von-service-schnittstellen]]
== Anbieten von Service-Schnittstellen

Dieser Abschnitt beschreibt die Realisierung von HttpInvoker-Schnittstellen (siehe <<Spring>>).
HttpInvoker-Schnittstellen sind interne Service-Schnittstellen, die innerhalb der Anwendungslandschaft durch andere Anwendungen genutzt werden dürfen.
Extern verfügbare Services sind durch WebService-Schnittstellen anzubieten, über einen ServiceGateway.

[[designvorgaben-2]]
=== Designvorgaben

* Interne Services werden per Spring-HttpInvoker angeboten.
* Es werden keine Komponenten des Anwendungskern extern verfügbar gemacht: Es wird stets eine eigene Service-Schicht implementiert.
Dazu gehört auch die Definition einer Service-Schnittstelle als Java-Interface (RemoteBean).
* Jede Service-Methode erhält einen zusätzlichen Parameter `AufrufKontext`. Im Aufrufkontext werden Informationen zum Aufrufer
(Name, Behördenkennzeichen, Rollen…) übermittelt.
Die Implementierungen verschiedener Aufrufkontext-Transportobjekte sind in der Bibliothek "isy-serviceapi-sst" enthalten.
* Die Implementierung der Service-Schnittstelle wird in eine Exception-Fassade und die eigentliche Service-Implementierung aufgeteilt.
* In der Service-Schnittstelle werden nur Transport-Exceptions und Transportobjekte verwendet.
Die Umwandlung der internen Exceptions und Entitäten auf Transport-Exceptions und -Objekte erfolgt in der Service-Schicht.
* Listen von Objekten in Ein- und Ausgabeparametern werden als Arrays übertragen.
Andere `Collection`-Typen sind nicht erlaubt.
* Beim Kompilieren der Schnittstellenprojekte muss auf die Java-Version geachtet werden.
Die Java-Version darf nicht neuer sein, als diejenige des Nutzers.
Ggf.
muss die Schnittstelle auf eine ältere Version kompiliert werden.

[[package-struktur-1]]
=== Package-Struktur

* Schnittstellen werden versioniert.
Die Versionsnummer wird dreistellig im Package-Namen der Serviceschnittstelle angegeben.
Beispiel: Die Version 1.0.0 der Schnittstelle der Komponente Meldung der Anwendung Vorlage-Register, wird in den folgenden
Packages implementiert: +
`de.bund.bva.cd.registercd.service.httpinvoker.v1_0_0.*`
* Interfaces, Transport-Exceptions und Transportobjekte werden im Package +
`<organisation>.<domäne>.<system>.service.httpinvoker.vX_Y_Z` +
implementiert
+
NOTE: Das sind genau die Inhalte, die im eigenen Projekt `<system>-httpinvoker-sst` implementiert werden.
+
* Die Implementierung der Service-Schnittstelle erfolgt im Package +
  `<organisation>.<domäne>.<system>.service.httpinvoker.vX_Y_Z.impl`.

[[klassendesign-2]]
=== Klassendesign

:desc-image-KDServiceSS: Klassendesign für HttpInvoker-Service-Schnittstellen
[id="image-KDServiceSS",reftext="{figure-caption} {counter:figures}"]
.{desc-image-KDServiceSS}
image::KDServiceSS.png[align="center"]

:desc-table-KDServiceSS: Klassenbeschreibung für Service-Schnittstellen
[id="table-KDServiceSS",reftext="{table-caption} {counter:tables}"]
.{desc-table-KDServiceSS}
[cols="1,2"]
|====
|*AuskunftRemoteBean* a|
Externes Interface für den Zugriff auf die Auskunft-Komponente per HttpInvoker.
Bei Nutzung einer Service-Schnittstelle generiert Spring auf Basis dieses Interfaces einen Proxy für den Remote-Zugriff. +
Die Methoden dieser Komponente verwenden ausschließlich Transportobjekte und -Exceptions. +
Die Überwachung der Service-Aufrufe (siehe Kapitel <<überwachung>>) wird als Aspekt der RemoteBean konfiguriert.
|*AuskunftToException* |Transport-Exception der Auskunft.
Jede Komponente darf ausschließlich Transport-Exceptions an ihrer Service-Schnittstelle werfen.
Details sind in <<FehlerbehandlungKonzept>> nachzulesen.
|*AufrufKontextTo* |`AufrufKontext` der Service-Utilities mit den Informationen zum Aufrufer (Name, Passwort, Rollen…).
|*RegisterEintragTo* |Transportobjekt für Register-Eintrag-Entitäten.
|*AuskunftExceptionFassade* a|
Die Klasse `AuskunftExceptionFassade` implementiert das `AuskunftRemoteBean`-Interface.
Die Exception-Fassade erhält damit alle Aufrufe der Auskunft-Service-Schnittstelle.
Diese werden an die Auskunft-Service-Implementierung (`AuskunftServiceImpl`) delegiert.
Die Aufgabe der Exception-Fassaden ist das Exception-Handling und -Mapping durchzuführen. +
Wichtig ist, einen Catch-Throwable-Block um den Aufruf der `AuskunftService`-Implementierung zu machen, um sicherzustellen, dass alle auftretenden Fehler gefangen werden.
Die Implementierung der Fehlerbehandlung wird im Detail in <<FehlerbehandlungKonzept>> beschrieben. +
In der Exception-Fassade muss die Correlation-ID aus dem AufrufKontext in den Logging-Kontext gesetzt werden (siehe Kapitel <<logging>>).
|*AuskunftService* |Internes Interface für den Auskunft-Service.
Diese Schnittstelle verwendet Transportobjekte aber noch die internen Exceptions.
Diese werden erst von der Exception-Fassade auf die eigentlichen Exceptions der AuskunftRemoteBean umgewandelt.
|*AuskunftServiceImpl* a|
Implementierung des `AuskunftService`.
In Service-Implementierung müssen die folgenden Aktivitäten durchgeführt werden:

* Berechtigungsprüfung
* Mappen der eingehenden Daten
* Aufrufen des Anwendungskerns (Auskunft)
* Mappen der ausgehenden Daten

Das Mappen der Daten wird mit Dozer durchgeführt.

NOTE: Dozer: Generischer Java-Bean zu Java-Bean Mapper (http://dozer.sourceforge.net)

Dies geschieht automatisiert, ohne dass man Mapping-Informationen hinterlegen muss.
Grund hierfür ist die strukturelle Gleichheit der Objekte des Anwendungskerns und der Service-Schicht.
Dadurch ist Dozer in der Lage diese Objekte generisch zu übersetzen.

In den Service-Implementierungen wird außerdem die Transaktionssteuerung durchgeführt.
Diese wird per Spring-AOP über Annotations konfiguriert (siehe Kapitel <<datenhaltung>>).
|====

[[realisierung-2]]
=== Realisierung

Zur Realisierung einer Service-Schnittstelle müssen einige Aktivitäten ausgeführt werden.
Diese werden im Folgenden beschrieben.

[[anlegen-des-schnittstellen-projekts]]
==== Anlegen des Schnittstellen Projekts

Das neue Projekt `<system>-httpinvoker-sst` muss angelegt werden.
Dazu wird eine neue `pom.xml` angelegt.
Wichtig ist, dass darin die Compiler-Version so festgelegt wird, wie es im Dokument <<ProduktKatalog>> vorgegeben ist.

Das Projekt muss ein Jar erzeugen, das von anderen Systemen zur Nutzung der Service-Schnittstelle benötigt wird.
In der Pom-Datei muss konfiguriert werden, dass das Jar in das Verzeichnis `repository-deploy` (Deployment-Repository) deployt wird.
Ein Beispiel dafür findet sich in <<Vorlageanwendung>>.

Das Schnittstellen-Projekt erhält dieselbe Group-ID wie das eigentliche Anwendungsprojekt.
Die Artifact-ID ist `<system>-httpinvoker-sst`.

[[realisierung-der-externen-service-schnittstelle]]
==== Realisierung der „externen“ Service-Schnittstelle

Das RemoteBean-Interface, die Transportobjekte und -Exceptions müssen im Schnittstellen-Projekt angelegt werden.

[[realisierung-der-service-implementierung]]
==== Realisierung der Service-Implementierung

Im Projekt der eigentlichen Anwendung müssen die Exception-Fassade, das Service-Interface (z.B. `AuskunftService`) und die Implementierung dieses Interfaces angelegt werden.

Im Rahmen der Implementierung muss ggf.
das Dozer-Mapping für die Transformation der Transport- auf die Entitätsobjekte angelegt werden.
Dozer wird als Spring-Bean in der Datei `src/main/resources/resources/spring/querschnitt.xml` konfiguriert.
Dabei werden die zuvor angelegten Mapping-Dateien in Dozer konfiguriert.

In derselben Konfigurationsdatei werden die Exception-Fassade und die Service-Implementierung als Spring-Beans konfiguriert.
Die Exception-Fassade erhält eine Referenz auf die Service-Implementierung per Dependency-Injection.
Genauso erhält die Service-Implementierung eine Referenz auf Dozer per Dependency-Injection.

In der Datei `src/main/resources/resources/spring/remoting-servlet.xml` wird die HttpInvoker-Konfiguration der Service-Schnittstelle durchgeführt.
Dazu werden das Remote-Bean-Interface und die zugehörige Implementierung in Form der Exception-Fassade konfiguriert.

In der Datei `src/main/webapp/WEB-INF/web.xml` muss das Dispatcher-Servlet (`org.springframework.web.servlet.DispatcherServlet`) eingebunden werden.
Als Parameter wird die zuvor angelegte Konfiguration "remoting-servlet.xml" übergeben.

Für jede Service-Schnittstelle wird ein Servlet-Mapping auf dieses Servlet konfiguriert.

Vor der Exception-Fassade wird mit Hilfe der Annotation `@StelltLoggingKontextBereit` die mit dem Aufrufkontext mitkommende Correlation-Id für das Logging registriert.

An den Methoden der Service-Implementierung werden die Annotationen `@StelltAufrufKontextBereit` und `@Gesichert` gemäß <<SicherheitNutzerdok>> verwendet, um den Zugriff auf
die Service-Methode zu autorisieren.

Beispiele dafür finden sich in <<Vorlageanwendung>>.

[[konfigurieren-der-service-schnittstelle]]
==== Konfigurieren der Service-Schnittstelle

Die angebotenen RemoteBeans (Service-Interfaces) werden in der Spring-Konfiguration `/src/main/resources/resources/spring/remoting-servlet.xml` eingetragen.
Der HttpInvoker-Service wird hier als Spring-Bean konfiguriert.
Der Bean-Name ist für die URL, unter welcher der Service erreichbar sein wird, wichtig.

In die `web.xml` der Anwendung muss ein Servlet-Mapping für die URL des Services festgelegt werden.
Alle Mappings zeigen dabei auf dasselbe HttpInvoker-Dispatcher-Servlet.
Dieses delegiert den Aufruf dann an die zuvor konfigurierte Spring-Bean.
Das Dispatching erfolgt an Hand der URL bzw.
des Bean-Namens.

[[einbinden-der-benötigten-bibliotheken]]
==== Einbinden der benötigten Bibliotheken

[[bibliotheken-für-das-service-schnittstellen-projekt]]
===== Bibliotheken für das Service-Schnittstellen-Projekt

Das Projekt der Service-Schnittstelle benötigt die in Tabelle <<table-GIDArtIDexp>> aufgelisteten Bibliotheken:

:desc-table-GIDArtIDexp: Bibliotheken für das Anbieten von Service-Schnittstellen
[id="table-GIDArtIDexp",reftext="{table-caption} {counter:tables}"]
.{desc-table-GIDArtIDexp}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
| de.bund.bva.isyfact | isy-exception-sst
| de.bund.bva.isyfact | isy-serviceapi-sst
|====

[[bibliotheken-für-die-implementierung-der-service-schnittstelle]]
===== Bibliotheken für die Implementierung der Service-Schnittstelle

In die Build-Konfiguration des Hauptprojekts des Anwendungssystems müssen folgende Bibliotheken aufgenommen werden:

:desc-table-GIDArtIDserss: Bibliotheken für das Anbieten von Service-Schnittstellen
[id="table-GIDArtIDserss",reftext="{table-caption} {counter:tables}"]
.{desc-table-GIDArtIDserss}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|<organisation>.<domäne>.<system> |<systemname>-httpinvoker-sst
|de.bund.bva.isyfact |isy-serviceapi-core
|de.bund.bva.isyfact |isy-exception-core
|org.springframework |spring-web
|org.springframework |spring-webmvc
|org.springframework |spring-aop
|org.springframework |spring-aspects
|net.sf.dozer |dozer
|====

[NOTE]
====
`<systemname>-httpinvoker-sst` fügt das Schnittstellen-Projekt als Abhängigkeit hinzu.

Die verwendete Version von Dozer ist dem Produktkatalog zu entnehmen.
====

[[nutzen-von-service-schnittstellen]]
== Nutzen von Service-Schnittstellen

Dieser Abschnitt beschreibt, wie Service-Schnittstellen genutzt, d.h. aufgerufen werden können.

[[designvorgaben-3]]
=== Designvorgaben

Die genutzte Schnittstelle soll vom eigenen Anwendungskern entkoppelt werden.
D.h. im eigenen Anwendungskern werden keine Exceptions oder Transportobjekte der genutzten Schnittstelle verwendet.
Dazu wird ein Wrapper um die Schnittstelle implementiert.

[[klassendesign-3]]
=== Klassendesign

:desc-image-implClntAd: Beispiel für die Implementierung eines Client-Adapters
[id="image-implClntAd",reftext="{figure-caption} {counter:figures}"]
.{desc-image-implClntAd}
image::implClntAd.png[align="center"]

Zum Zugriff auf den Service wird im Normalfall ein Adapter im Client implementiert (`AuskunftAdapter`). Dieser Adapter entkoppelt den Anwendungskern des Clients vom Service.

Im Adapter wird im Wesentlichen eine Wrapper-Klasse (`AuskunftWrapper`) implementiert.
Diese führt das Mapping der Exceptions und der Daten durch.
Der Adapter implementiert im Beispiel ein eigenes „Auskunft“-Interface für die Nutzung durch die Client-Anwendung.

Für die Remote Zugriffe wird der `HttpInvokerProxy` benutzt.
Dieser wird automatisch von Spring erzeugt.
Er bietet das RemoteBean-Interface auf Client-Seite an und sorgt dafür, dass Aufrufe per HttpInvoker an den Service weitergereicht werden.

[[realisierung-3]]
=== Realisierung

[[einbinden-der-schnittstellen-bibliothek]]
==== Einbinden der Schnittstellen-Bibliothek

Zur Realisierung wird die Bibliothek mit der zu nutzenden Service-Schnittstelle benötigt.
Dieses befindet sich im Deployment-Repository der zu nutzenden Anwendung.
Das Jar wird in das eigene Projekt-Repository kopiert und via Maven eingebunden.

Zusätzlich müssen die HttpInvoker-Bibliotheken von Spring eingebunden werden.
Eine vollständige Liste zeigt Tabelle <<table-BibServNutz>>.

:desc-table-BibServNutz:  Bibliotheken für Service-Nutzung
[id="table-BibServNutz",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibServNutz}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|<organisation>.<domäne>.<system> |<systemname>-httpinvoker-sst
|de.bund.bva.isyfact |isy-serviceapi-core
|org.springframework |spring-web
|org.springframework |spring-aop
|org.springframework |spring-aspects
|====

[[durchführen-der-konfiguration]]
==== Durchführen der Konfiguration

Spring erzeugt anhand des Service-Interfaces HttpInvoker-Proxies, die den eigentlichen HttpInvoker-Aufruf durchführen.
Diese Proxies werden als Spring-Bean konfiguriert:

:desc-listing-proxconf: Proxy-Konfiguration
[id="listing-proxconf",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-proxconf}
[source,xml]
----
<bean id="xxxRemoteBean"
class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean">
<property name="serviceUrl" value="${service.xxx.url}"/>
<property name="serviceInterface" value="<organisation>.<domäne>.<system>.….xxxRemoteBean"/>
</bean>
----

Auf der Bean können alle Methoden des Interfaces `serviceInterface` aufgerufen werden, der Aufruf erfolgt dann automatisch
per HttpInvoker gegen das in `serviceUrl` konfigurierte Ziel-System.

NOTE: Die URL wird als betriebliche Konfiguration in eine Property-Datei ausgelagert und durch den PropertyPlacerHolder von Spring ersetzt.

[[erweiterung-um-die-aufrufwiederholung-mittels-service-utilities]]
==== Erweiterung um die Aufrufwiederholung mittels Service Utilities

Die in diesem Kapitel aufgeführte Konfiguration eines aufzurufenden Dienstes kann durch die Verwendung einer Aufruf-Wiederholungsimplementierung
erweitert werden, so dass Aufrufe bei Timeouts wiederholt werden.
Dies ist nur notwendig, sofern eine Aufrufwiederholung eine Anforderung an die Anwendung ist.
Für die Aufruf-Wiederholung ist lediglich die Spring-Konfiguration des Proxies anzupassen:

:desc-listing-KDmSAWied: Konfiguration der Service-API mit Aufruf-Wiederholungen
[id="listing-KDmSAWied",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-KDmSAWied}
[source,xml]
----
<bean id="xxxRemoteBean" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean">
<property name="serviceInterface" value="<organisation>.<domäne>.<system>.….xxxRemoteBean" />
<property name="serviceUrl" value="${service.xxx.url}" />

<property name="httpInvokerRequestExecutor" ref="xxxRequestExecutor"/>
</bean>
<bean id="xxxRequestExecutor"
class="de.bund.bva.pliscommon.serviceapi.core.httpinvoker.TimeoutWiederholungHttpInvokerRequestExecutor">
<property name="anzahlWiederholungen" value="${xxx.service.wiederholungen}" />
<property name="timeout" value="$xxx.service.timeout}" />
</bean>
----

Auf der Bean (`xxxRequestExecutor`) sind die `anzahlWiederholungen` und der `timeout` konfiguriert.
Dieser `RequestExecutor` erweitert den Standard-`RequestExecutor` von Spring um die Möglichkeit Timeouts zu definieren und eine
konfigurierte Anzahl an Aufruf-Wiederholungen durchzuführen.
Dieser `RequestExecutor` ist der Spring-HttpInvokerProxyFactoryBean bekannt zu machen.
// Alle Unterschiede zur Konfiguration ohne die Verwendung der Service-API für Aufruf-Wiederholungen und Timeouts sind fett markiert im Code-Beispiel.

[[implementierung-des-wrappers]]
==== Implementierung des Wrappers

Zur Entkopplung des eigenen Anwendungskerns von der Schnittstelle wird ein Wrapper für die Schnittstelle implementiert.
Der Wrapper führt das Mapping der internen Datenobjekte auf die Transportobjekte durch.
Dieses kann bei Bedarf mit Dozer gemacht werden.

Zusätzlich führt der Wrapper das Exception-Handling durch.
Der Wrapper kann auftretende Exceptions in eigene Exceptions umwandeln (Exception-Chaining) oder explizit behandeln.

[[batch-verarbeitung]]
== Batch-Verarbeitung

In diesem Kapitel wird die Implementierung von Batches zu einer Anwendung beschrieben.

[[designvorgaben-4]]
=== Designvorgaben

* Die Batch-Verarbeitung verwendet den Anwendungskern der zugehörigen Anwendung.
Der Anwendungskern ist Teil des Batch-Deployments, d.h. der Code ist sowohl Teil der Server-Anwendung als auch der Batch-Anwendung in Bezug auf Deploymenteinheiten.
* Zur Realisierung der Batchlogik wird eine Batch-Ausführungs-Bean implementiert.
* Falls für die Verarbeitung im Batch eigene Fachlogik benötigt wird, ist diese trotzdem den entsprechenden Anwendungskomponenten der zugehörigen Fachanwendung hinzuzufügen.
* Im Rahmen der Initialisierung hat die Ausführungs-Bean unter anderem die Aufgabe, die Konsistenz und Korrektheit der Eingabedaten zu prüfen.
* Falls die zu verarbeitenden Sätze eines Batches das Ergebnis einer Datenbank-Query sind, ist in der Initialisierung die Query über eine Anwendungskomponente der zugehörigen Fachanwendung abzusetzen.
Diese Query soll die (fachlichen) Schlüssel von Entitäten, nicht Entitäten selbst auslesen.
* Die Batches sind möglichst robust zu konstruieren: Falls auf ein fachliches Problem in der Ausführungs-Bean reagiert werden kann, sollte dies getan werden.
* Batches erzeugen ein Ausführungsprotokoll.
Der Batchrahmen, die Steuerungsimplementierung, die jeden Batch und dessen Arbeitsschritte steuert, stellt die notwendige Implementierung bereit.
Die Ausführungs-Bean übermittelt dem Batchrahmen Status-Informationen für das Protokoll.
* Batches verwenden einen (konfigurierten) technischen Benutzer, um sich vor Start der fachlichen Verarbeitung am Access-Manager des Anwendungssystems oder der Anwendungslandschaft zu authentifizieren.
* Alle Batches zu einer Anwendung werden als eigenständige Deployment-Einheit ausgeliefert.

[[klassendesign-4]]
=== Klassendesign

:desc-image-KDBatch: Klassendesign eines Batches
[id="image-KDBatch",reftext="{figure-caption} {counter:figures}"]
.{desc-image-KDBatch}
image::KDBatch.png[align="center",width=80%,pdfwidth=80%]

<<image-KDBatch>> zeigt eine beispielhafte Implementierung eines Batches, der die Komponenten „Auskunft“ und „Basisdaten“ verwendet.

Im Normalfall erhält die Batch-Bean (`AuskunftBatch`) eine Referenz auf die Komponenten des Anwendungskerns per Spring-Dependency.
Für die Komponente Basisdaten erfolgt der Zugriff wie immer mittels statischer Aufrufe der DAOs.

Der Batchrahmen definiert das Interface `BatchAusfuehrungsBean`. Dieses dient der Steuerung des Batches durch den Batchrahmen.
Es muss von der Batch-Ausführungs-Bean implementiert werden.
Der Batchrahmen sorgt auch für die Initialisierung und Ausführung des Batches.

Der Batchrahmen übernimmt die Transaktionssteuerung.
Die Transaktionssteuerung im Batch sieht vor, mehrere Arbeitsschritte in einer Transaktion abzuwickeln.
Die Größe der Transaktion (Commit-Rate) wird über den Batchrahmen konfiguriert.

[[realisierung-4]]
=== Realisierung

[[einbinden-der-bibliothek]]
==== Einbinden der Bibliothek

Zur Realisierung von Batches muss die in Tabelle <<table-BibRealBatch>> aufgelistete Bibliothek eingebunden werden.

:desc-table-BibRealBatch: Bibliotheken für die Realisierung von Batches
[id="table-BibRealBatch",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibRealBatch}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-batchrahmen
|====

[[implementierung-der-batch-logik]]
==== Implementierung der Batch-Logik

Die Batch-Logik wird implementiert, in dem eine Batch-Bean im Package `<organisation>.<domäne>.<anwendung>.batch` implementiert wird.
Für die Realisierung ist es notwendig, dass die Batch-Bean das Interface `BatchAusfuehrungsBean` aus der Bibliothek isy-batchrahmen implementiert.

Der Batchrahmen ruft als erstes die Methode „initialisieren“ auf.
Dabei werden alle zur Initialisierung benötigten Informationen übergeben.
Details dazu werden im JavaDoc der Methode beschrieben.

Der Parameter `BatchErgebnisProtokoll` enthält eine Referenz auf ein Protokollobjekt, welches der Batch verwendet, um Protokoll-Meldungen und Statistiken an den Batchrahmen zu übergeben.

[[konfiguration-des-batches-und-batchrahmens]]
==== Konfiguration des Batches und Batchrahmens

Für jeden Batch muss eine Property-Datei in `/src/main/resources/resources/batch` angelegt werden.
In dieser statischen Konfiguration werden unter anderem die Batch-ID und die Transaktionssteuerung konfiguriert.
Eine Beschreibung der Parameter ist in <<BatchDetailkonzept>> enthalten.

Die betriebliche Konfiguration des Batches ist identisch zu derjenigen der zugehörigen Anwendung.
Auch Parameter, die nur für den Batch benötigt werden, werden in die betriebliche Konfiguration der Fachanwendung aufgenommen.

[[spring-konfiguration-anlegen]]
==== Spring-Konfiguration anlegen

Für den Batchrahmen werden die in Tabelle 10 aufgelisteten Konfigurationsdateien benötigt.

:desc-table-KonfBatchRahmen: Spring Konfiguration für den Batchrahmen
[id="table-KonfBatchRahmen",reftext="{table-caption} {counter:tables}"]
.{desc-table-KonfBatchRahmen}
[cols="2m,1m,3",options="header"]
|====
|Pfad |Datei |Beschreibung
|src/main/resources/resources/batch/rahmen |Batchrahmen.xml |Hier werden die Spring-Beans des Batchrahmens definiert.
Zusätzlich muss für jeden existierenden Batch die Ausführungs-Bean als Spring-Bean definiert werden.
|====

Der Batch verwendet den Anwendungskern der eigentlichen Anwendung.
Dafür wird eine Spring-Konfiguration benötigt.
Als Basis können die Spring-Konfigurationen der Anwendung verwendet werden.
Diese werden anschließend wie in Tabelle <<table-KonfBatchAWK>> beschrieben angepasst:

INFO: Hier das Problem der Tabellen-Farben

:desc-table-KonfBatchAWK: Spring Konfiguration für den Anwendungskern für Batches
[id="table-KonfBatchAWK",reftext="{table-caption} {counter:tables}"]
.{desc-table-KonfBatchAWK}
[cols="2m,2m,5",options="header"]
|====
|Pfad  |Datei    |Beschreibung
.4+|src/main/resources/resources/batch/register  |jpa.xml  |In der Bean `EntityManagerFactory` muss der
Parameter `PersistenceUnitName` so umkonfiguriert werden, dass die `PersitenceUnit` für den Batch (siehe `persistence.xml`) verwendet wird.
 |komponenten.xml |Bei der Bean `AufrufKontext` muss der Scope `request` entfernt werden. Alternativ
dazu kann über die Klasse `SimpleRequestContextAttributes` aus isy-util auch der Request-Kontext für den Batch nachgebildet werden.
 |querschnitt.xml  a|Die Beans für die JMX-Überwachungs­schnittstelle werden entfernt.

Die Timer für Watchdog und Systemprüfung werden entfernt.
 |hibernate.cfg.xml |Die Klassen BatchStatus und BatchKon­figurationsparameter werden über
`<mapping resource="resources/plis-batchrahmen/hibernate/hibernate-mapping.xml"/>` eingebunden.
|src/main/resources/META-INF |persistence.xml |Hier muss die spezielle Hibernate­konfiguration (`hibernate.cfg.xml`)
als neue Persistence-Unit eingetragen werden.
|====

Bei geeigneter Aufteilung der Spring-Konfiguration kann auch die Konfiguration der Anwendung direkt verwendet werden.
Dazu müssen Timertasks und JMX-Beans in eigene Spring-Konfigurationen ausgliedert werden.

[[konfiguration-des-batch-deployments]]
==== Konfiguration des Batch-Deployments

Für das Deployment des Batches wird ein neues Maven-Projekt `<system>-batch` angelegt.
Dieses hat die Aufgabe das Deployment-Paket für den Batch zusammenzustellen.

Dazu wird eine neue pom.xml angelegt, die als Ziel-Typ ein Jar mit allen Dateien des Batches erzeugt.
Zusätzlich können in diesem Projekt Shell-Skripte und ähnliches für den Batch abgelegt werden.
Ein Beispiel ist in <<Vorlageanwendung>> enthalten.

Das Batch-Projekt enthält keinen Java-Code.
Die Batch-Beans liegen im normalen Anwendungsprojekt.

[[querschnitt]]
= Querschnitt

In diesem Kapitel wird die Umsetzung querschnittlicher Aspekte beschrieben.

[[logging]]
== Logging

In diesem Abschnitt wird beschrieben, wie das Logging umzusetzen und zu konfigurieren ist.

[[designvorgaben-5]]
=== Designvorgaben

* Für Logging wird Log4j verwendet.
* Es wird ein Debug-, Info- und ein Error-Log geführt.
Die Zuordnung der Log-Levels auf diese Log-Arten wird in <<LoggingKonzept>> definiert.
Ebenso welche Informationen mit welchem Log-Level ausgeben werden sollen.
* Für das Logging wird das im Rahmen der IsyFact erstellte Single-Line-Layout verwendet.
* In jeder Log-Meldung ist eine Correlation-ID mitzuloggen.
Diese identifiziert den Aufruf über die Anwendungslandschaft hinweg.
* Log-Konfigurationen müssen zur Laufzeit änderbar sein.

[[realisierung-5]]
=== Realisierung

[[implementierung-von-log-ausgaben]]
==== Implementierung von Log-Ausgaben

Log-Ausgaben können an beliebigen Stellen im Code erzeugt werden.
Dazu wird in jeder Klasse ein eigener Logger erzeugt:

[source,java]
----
public static final Logger _LOG_ = Logger.getLogger(XXX.class);
----

Wichtig ist, in der Exception-Fassade an der Service-Schnittstelle (siehe Kapitel <<klassendesign-2>>) die Correlation-ID zu setzen:

[source,java]
----
@StelltLoggingKontextBereit
public int cdErworben(AufrufKontext kontext, …)
…
----


[[einbinden-der-bibliotheken-1]]
==== Einbinden der Bibliotheken

Um die Logging Funktionen in der eigenen Anwendung nutzen zu können müssen die in Tabelle <<table-BibLog>> aufgelisteten Bibliotheken eingebunden werden.

:desc-table-BibLog: Bibliotheken für das Logging
[id="table-BibLog",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibLog}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-logging
|====

Dadurch wird Log4j automatisch in die Anwendung integriert.


[[anlegen-der-konfiguration]]
==== Anlegen der Konfiguration

In `/src/main/resources/config/` muss die Datei log4j.properties angelegt werden.
Diese definiert, wohin Log-Ausgaben geschrieben werden und wie das Layout dafür ist.
Für das Layout wird die Klasse `SingleLinePatternLayout` aus „isy-logging“ verwendet.

In der web.xml muss der Pfad für die Log-Konfiguration und das Polling darauf konfiguriert werden.
Dazu müssen die Parameter `log4jConfigLocation` und `log4jRefreshInterval` als Context-Parameter definiert werden.

Ebenfalls in der `web.xml` muss die Klasse `org.springframework.web.util.Log4jConfigListener` als Servlet-Listener eingebunden werden.

[[konfiguration]]
== Konfiguration

In diesem Kapitel wird die Verarbeitung von Konfigurationen in Anwendungen beschrieben.

[[designvorgaben-6]]
=== Designvorgaben

* Für die Konfiguration werden betriebliche, statische und Benutzerkonfigurationen unterschieden.
Eine Definition und Kriterien zur Typisierung können in <<UeberwachungKonfigKonzept>> nachgelesen werden.
* Betriebliche Konfigurationen werden als Properties-Datei in `/src/main/resources/config` abgelegt.
* Statische Konfigurationen werden als Datei in `/src/main/resources/resources` abgelegt.
* Benutzerkonfigurationen werden in der Datenbank abgelegt.
* Betriebliche Konfigurationen können in Ausnahmefällen zur Laufzeit aktualisiert werden.
* Für das Laden von betrieblichen Konfigurationen wird die Bibliothek „isy-konfiguration“ verwendet.

[[realisierung-6]]
=== Realisierung

[[einbinden-der-bibliotheken-2]]
==== Einbinden der Bibliotheken

Die in <<table-BibfdKonf>> aufgeführte Konfigurationsbibliothek muss eingebunden werden.

:desc-table-BibfdKonf: Bibliotheken für die Konfiguration
[id="table-BibfdKonf",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibfdKonf}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-konfiguration
|====

Die Konfigurationsbibliothek ermöglicht den typsicheren Zugriff auf Konfigurationsparameter in Property-Dateien.
Außerdem implementiert sie einen Polling-Mechanismus, der dazu genutzt werden kann Konfigurationsänderungen zur Laufzeit bekannt zu machen.

[[auslesen-von-konfigurationsparametern-in-der-anwendung]]
==== Auslesen von Konfigurationsparametern in der Anwendung

Zum Zugriff auf die in den betrieblichen Konfigurationsdateien abgelegten Parametern aus der Anwendung heraus wird die Klasse
`de.bund.bva.pliscommon.konfiguration.common.impl.ReloadablePropertyKonfiguration` aus isy-konfiguration verwendet.
Diese wird als Spring-Bean konfiguriert und erhält im Konstruktor eine Liste aller betrieblichen Property-Dateien.
Komponenten, welche Zugriffe auf Parameter benötigen, erhalten eine Referenz auf diese Bean und können über die angebotenen
Getter-Methoden die Konfigurationsparameter auslesen.

Für die Namen der Konfigurationsparameter wird eine abstrakte Klasse `KonfigurationSchluessel` angelegt, welche alle Parameternamen als String-Konstanten enthält.

Im Ausnahmefall können Parameter zur Laufzeit geändert werden.
Solche Parameter werden vorzugsweise nicht in Instanzvariablen gehalten, sondern bei jeder Benutzung ausgelesen.
Alternativ kann der Eventlistener-Mechanismus der Konfigurationsbibliothek verwendet werden.

Damit die Konfiguration periodisch auf Änderungen überwacht wird, muss ein Timer erzeugt werden.
Dieses erfolgt ebenfalls über eine Spring-Timer-Task.
Details dazu werden in <<UeberwachungKonfigKonzept>> beschrieben.
Ein entsprechendes Beispiel ist in der <<Vorlageanwendung>> umgesetzt.

[[konfigurationsparameter-in-spring-konfigurationen]]
==== Konfigurationsparameter in Spring-Konfigurationen

Betriebliche Konfigurationsparameter, z.B. für die Datenbankverbindung, dürfen nicht in der Spring-Konfiguration abgelegt werden.
Diese werden über den Property-Replace-Mechanismus von Spring in betriebliche Property-Dateien ausgelagert.
Dazu wird die Bean `org.springframework.beans.factory.config.PropertyPlaceholderConfigurer` in die Spring-Konfiguration aufgenommen.
Dieser wird die Liste der betrieblichen Konfigurationsdateien gegeben.
Betriebliche Parameter können so als Variablen in der Spring-Konfiguration angegeben werden.
Spring sorgt für eine Ersetzung der Parameter beim Anwendungsstart.
Details dazu können in <<Spring>> nachgelesen werden.

[[fehlerbehandlung]]
== Fehlerbehandlung

In diesem Kapitel wird beschrieben, wie die Fehlerbehandlung durchzuführen ist.

[[designvorgaben-7]]
=== Designvorgaben

* In jeder Anwendung bzw.
Bibliothek wird eine eigene Exception-Hierarchie angelegt.
* Für Anwendungs-Exceptions wird die oberste Exception dieser Hierarchie von den in der Bibliothek „isy-exception-core“ enthaltenen Exception-Klassen abgeleitet.
Diese Ober-Exceptions sind als abstrakt zu kennzeichnen.
* Für Exceptions in selbst entwickelten Bibliotheken werden nicht die Exception-Klassen aus „isy-exception-core“ verwendet.
Die zugrundeliegenden Designprinzipien sind jedoch identisch umzusetzen.
So wird für jede Bibliothek eine abstrakte Ober-Exception angelegt.
Diese sorgt für das Laden der Nachrichten, erbt aber direkt von einer der `java.lang.Exception` bzw `java.lang.RuntimeException`.
* Fehlertexte werden in Resource-Bundles ausgelagert und über eine Fehler-ID indentifiziert.
Die Schlüssel der Fehler-IDs werden in einer Konstantenklasse zusammengefasst.
* Exceptions werden grundsätzlich nur zur Signalisierung abnormer Ergebnisse bzw.
Situationen eingesetzt.
* Exceptions sind in der Regel zu behandeln und zu loggen.
Ist es nicht möglich die Exception zu behandeln, muss sie an den Aufrufer weitergegeben werden.
Die Exception wird im Fall eines Weiterwerfens nicht geloggt.
* Nur Exceptions in Methodensignaturen verwenden, die auch vorkommen können.
* Bei der Behandlung von Fehlern ist ein geordneter Systemzustand herzustellen, z. B. das Schließen
der Datenbankverbindung über einen `finally`-Block.
* Fehler sollten möglichst früh erkannt werden und zu entsprechenden Ausnahmen führen.
* Interne Exceptions dürfen in der Service-Schnittstelle nicht vorkommen.
* Catch-Blöcke dienen der Fehlerbehandlung und dürfen nicht als `else`-Zweige genutzt werden.
* Keine leeren Catch-Blöcke.
* Das destruktive Wrappen einer Exception zerstört den StackTrace und ist nur für Exceptions an den Außen-Schnittstellen sinnvoll.
Destruktiv gewrappte Exceptions sind in jedem Fall vor dem Wrappen zu loggen.

Weitere Hinweise für die richtige Behandlung von Fehlern sind in <<FehlerbehandlungKonzept>> enthalten.

[[paketstruktur]]
=== Paketstruktur

Exceptions die querschnittlich, also von mehreren Komponenten genutzt werden, werden im Paket:

`<organisation>.<domäne>.<anwendung>.common.exception`

NOTE: `<organisation>` z.B. bva.bund.de

implementiert. Komponentenspezifische Exceptions, also solche die nur von einer einzigen
Komponente genutzt werden, gehören in das Paket:

`<organisation>.<domäne>.<anwendung>.core.<komponente>`

[[realisierung-7]]
=== Realisierung

Die Bibliothek ist in zwei Teile aufgeteilt:

* isy-exception-core und
* isy-exception-sst

Das Core-Paket enthält anwendungsinterne Exception-Klassen und Hilfsklassen für das Exception-Mapping.
Im Schnittstellen-Projekt sind die Klassen für die Transport-Exceptions enthalten.
Wenn das Core-Paket eingebunden wird, wird über Maven automatisch das Schnittstellen-Projekt mit eingebunden.
Die explizite Einbindung von „isy-exception-sst“ sollte dann entfernt werden.

Die Core-Bibliothek wird im Wesentlichen im Anwendungskern bzw.
der Service-Schnittstellen-Implementierung benötigt
(siehe <<bibliotheken-für-die-implementierung-der-service-schnittstelle>>). Für Service-Schnittstellen
werden lediglich die Transport-Exceptions aus „isy-exception-sst“ benötigt
(siehe Kapitel <<bibliotheken-für-das-service-schnittstellen-projekt>>).

[[einbinden-der-bibliothek-1]]
==== Einbinden der Bibliothek

Zur Realisierung der Fehlerbehandlung und Implementierung von Exceptions müssen die in <<table-BibfdFehler>>
aufgelisteten Bibliotheken eingebunden werden.

:desc-table-BibfdFehler: Bibliotheken für die Fehlerbehandlung
[id="table-BibfdFehler",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibfdFehler}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-exception-core
|de.bund-bva.isyfact |isy-util
|====

„isy-exception-core“ enthält abstrakte Exception-Klassen die in Anwendungen zu verwenden sind. „isy-util“ enthält Hilfsklassen zum Laden von Fehlertexten.

[[anlegen-der-exception-klassen]]
==== Anlegen der Exception-Klassen

In jeder Anwendung wird für jede Exception-Art (technisch, fachlich) eine eigene Oberklasse angelegt.
Diese erbt von der entsprechenden Klasse aus „isy-exception-core“. Zum Laden der
 Fehlertexte wird das Interface FehlertextProvider aus derselben Bibliothek verwendet.
In „isy-util“ ist die Implementierung `MessageSourceFehlertextProvider` enthalten.
Diese unterstützt das Laden von Fehlertexten aus einer Spring-Message-Source.
Ein Beispiel für die Verwendung ist in der <<Vorlageanwendung>> enthalten.

[[fehlerbehandlung-an-der-anwendungsschnittstelle]]
==== Fehlerbehandlung an der Anwendungsschnittstelle

Fehler sind entweder zu behandeln und zu loggen oder weiterzuwerfen.
Es muss jedoch sichergestellt werden, dass interne Fehler der Anwendung nicht über die
System-Schnittstelle (siehe <<anbieten-von-service-schnittstellen>>) geworfen werden.
Dazu wird in der Exception-Fassade eine explizite Fehlerbehandlung mit einem Catch-Throwable-Block durchgeführt.

Alle Exceptions der Anwendungen werden hier in Transport-Exceptions umgewandelt.
Dazu wird das im Folgenden beschrieben Muster verwendet.

Es wird ein Catch-Block für alle auftretenden eigenen Exceptions angelegt.
In jedem Catch-Block wird die Exception geloggt und über `PlisExceptionMapper.mapException`
in eine passende Transport-Exception umgewandelt.
Als letztes wird ein Catch-Throwable-Block eingefügt.

Hier wird für die aufgetretene Exception über `PlisExceptionMapper.createToException`
eine neue Transport-Exception erzeugt.
Zur Ermittlung der Fehler-ID wird eine Klasse AusnahmeIdUtil angelegt.
Diese implementiert eine statische Methode `getAusnahmeId`, die zu einer übergebenen Exception
eine passende Fehler-ID ermittelt.
Vor dem Werfen der so erzeugten Exception über die Schnittstelle wird ein Log-Eintrag erzeugt.

Beim Umwandeln der internen Exceptions in Transport-Exceptions wird der Stack-Trace der internen Exceptions verworfen.

Ein Beispiel hierfür ist wieder in <<Vorlageanwendung>> enthalten.

[[protokollierung]]
== Protokollierung

In diesem Kapitel wird beschrieben, wie eine fachliche Protokollierung umzusetzen ist.


[[designvorgaben-8]]
=== Designvorgaben

* Protokolleinträge und Daten des Anwendungsfalls (Meldung, Auskunft…) werden innerhalb derselben
Transaktion geschrieben.
* Protokoll-Tabellen werden im Datenbank-Schema der Anwendung abgelegt.
* Binärdaten werden nicht protokolliert.
Es wird lediglich eine Referenz auf den entsprechenden Datensatz gespeichert.
* Referenzierte Binärdaten, dürfen erst dann physikalisch gelöscht werden, wenn auch der Protokolldatensatz entfernt wird.
Bis dahin werden die Binärdaten mit einem Lösch-Flag versehen und stehen nur noch für die Protokollrecherche zur Verfügung, nicht mehr in der eigentlichen Anwendung.
Dies kann über ein eigenes Feld in den Protokoll-Daten und einem Foreign-Key-Constraint in der Datenbank sichergestellt werden.

[[realisierung-8]]
=== Realisierung

[[einbinden-der-bibliothek-2]]
==== Einbinden der Bibliothek

Zur Realisierung der Protokollierung muss die in Tabelle 15 aufgelisteten Bibliothek eingebunden werden.

:desc-table-BibfdProt: Bibliotheken für die Protokollierung
[id="table-BibfdProt",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibfdProt}
[cols=",",options="header",]
|====
|GroupId |ArtifactId
|de.bund.bva.pliscommon |plis-protokollierung
|====

Die Bibliothek enthält Basis-Entitäten, von denen eigene Protokollentitäten erben müssen.


[[implementierung-der-protokollierungskomponente]]
==== Implementierung der Protokollierungskomponente

Die Protokollierungskomponente wird analog zu den übrigen fachlichen Komponenten entwickelt.
Es wird keine Basisimplementierung dafür vorgeben.

Es müssen eigene Entitätsklassen für die Protokolleinträge angelegt werden.
Diese müssen von der abstrakten Entitätsklasse aus „plis-protokollierung“ erben.

Ein Klassendiagram ist in <<ProtokollierungKonzept>> enthalten.

Die Protokollierungskomponente benötigt in der Regel Kontextinformationen über den Aufrufer.
Dazu wird in der Anwendung eine AufrufKontext-Komponente (siehe <<aufrufkontextverwaltung>>) eingebunden.

[[aufrufkontextverwaltung]]
== Aufrufkontextverwaltung

Einige Komponenten der Anwendung, z.B. die Protokollierung oder die Autorisierung benötigen
Kontextinformationen über den Aufrufer.
Damit diese nicht durch die gesamte Anwendung gereicht werden müssen, kann in der Anwendung
ein AufrufKontextVerwalter verwendet werden.

[[designvorgaben-9]]
=== Designvorgaben

* Die Komponente wird so implementiert, dass sie spezifische Informationen über den Aufruf-Kontext speichern kann (z.B. Name des aufrufenden Benutzers).
* Die Komponente kann in einer Anwendung so erweitert werden, dass sie beliebige weitere Kontext-Informationen aufnehmen kann.

[[realisierung-9]]
=== Realisierung

[[einbinden-der-bibliothek-3]]
==== Einbinden der Bibliothek

Zur Realisierung des AufrufKontext müssen die in <<table-BibfdPVdAK>> aufgelisteten Bibliotheken eingebunden werden.

:desc-table-BibfdPVdAK: Bibliotheken für die Verwaltung des AufrufKontext
[id="table-BibfdPVdAK",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibfdPVdAK}
[cols=",",options="header",]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-aufrufkontext
|====

Die Bibliothek isy-aufrufkontext enthält die Komponente `AufrufKontextVerwalter`, welcher den benutzerspezifischen Aufrufkontext im Thread-Scope (alternativ Request-Scope) hält.

[[konfiguration-der-bibliothek]]
==== Konfiguration der Bibliothek

Die Komponente `AufrufKontextVerwalter` wird als Spring-Bean konfiguriert.
Dabei wird festgelegt, dass Spring eine neue Instanz für jeden Thread (alternativ Request) anlegen soll:

:desc-listing-ARKxtVerw: AufrufKontextVerwalter
[id="listing-ARKxtVerw",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-ARKxtVerw}
[source,java]
----
<bean id="aufrufKontextVerwalter" scope="request" class="de.bund.bva.pliscommon.aufrufkontext.impl.AufrufKontextVerwalterImpl">
<aop:scoped-proxy />
</bean>
----

Der vom AufrufKontextVerwalter verwaltete AufrufKontext wird beim Aufruf der Anwendung in der Service-Schnittstelle oder im DialogController der GUI gesetzt und steht fortan, während der Verarbeitung des Requests, in der gesamten Anwendung zur Verfügung.

Komponenten, die diese Informationen benötigen, erhalten dazu einfach eine Referenz auf den
AufrufKontextVerwalter per Dependency Injection.

Zur Entgegennahme des AufrufKontextes an der Service-Schnittstelle kann eine Annotation
`@StelltAufrufKontextBereit` verwendet werden.
Die Konfiguration ist in <<SicherheitNutzerdok>> beschrieben.

[[authentifizierung-und-autorisierung]]
== Authentifizierung und Autorisierung

Dieses Kapitel beschreibt die Realisierung der Authentifizierung und Autorisierung von Anfragen.

[[designvorgaben-10]]
=== Designvorgaben

* Die Authentifizierung von Anfragen wird im Servicegateway und im Portal mit Hilfe des Access Managers durchgeführt.
* Prozesse, die innerhalb des Anwendungssystems oder der Anwendungslandschaft starten (z.B. Timertasks, Batches) verwenden einen technischen Benutzer und authentifizieren diesen selbständig gegen den Access Manager.
* Die Berechtigungsprüfung ist in der Anwendung deklarativ zu definieren bzw.
zu programmieren.
* Eine erste Berechtigungsprüfung erfolgt in der Service-Schnittstelle oder im Web-GUI-Dialogcontroller jeder Anwendung.
Es wird geprüft, ob der Aufrufer den Service oder den Dialog überhaupt verwenden darf.
* In jeder Service-Methode wird ein Parameter `AufrufKontext` mit den Daten des aufrufenden Benutzers übermittelt.
Dieser Parameter wird im `AufrufKontextVerwalter` hinterlegt und beim Aufruf weiterer Nachbarsysteme durchgereicht.
* In der Web-GUI wird ein vom Access-Manager bereitgestellter http-Header mit den
Daten des aufrufenden Benutzers entgegengenommen und in einen `AufrufKontext` gewandelt.
Dieser Parameter wird im `AufrufKontextVerwalter` hinterlegt und beim Aufruf weiterer Nachbarsysteme durchgereicht.

[[realisierung-10]]
=== Realisierung

[[einbinden-der-bibliothek-4]]
==== Einbinden der Bibliothek

Zur Realisierung der Autorisierung müssen die in <<table-Bibfdautor>> aufgelisteten Bibliotheken eingebunden werden.

:desc-table-Bibfdautor: Bibliotheken für die Autorisierung
[id="table-Bibfdautor",reftext="{table-caption} {counter:tables}"]
.{desc-table-Bibfdautor}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-sicherheit
|de.bund.bva.isyfact |isy-serviceapi-sst
|====

Die Bibliothek „isy-sicherheit“ enthält die Komponenten `Sicherheit` und `BerechtigungsManager`.

Die Bibliothek „isy-serviceapi-sst“ enthält das Transportobjekt `AufrufKontextTo`, das zur Übermittlung der Authentifizierungsdaten über Schnittstellenaufrufe benutzt wird.

Zusätzlich wird als Abhängigkeit der `AufrufKontextVerwalter` (siehe <<aufrufkontextverwaltung>>) benötigt,
der die Informationen zum Aufrufer kennt.

[[konfiguration-der-sicherheitskomponente]]
==== Konfiguration der Sicherheitskomponente

Die Komponente Sicherheit wird als Spring-Bean in der
Datei `src/main/resources/resources/spring/querschnitt/sicherheit.xml` konfiguriert.

Die einer Rolle zugeordneten Rechte werden in der Datei `/src/main/resources/resources/rollenrechte.xml` konfiguriert.

[[prüfen-der-berechtigung]]
==== Prüfen der Berechtigung

Die Berechtigungsprüfung erfolgt in der Regel vor der fachlichen Verarbeitung in der Service-Schnittstelle oder im Dialog-Controller einer Anwendung.
Dies erfolgt über Annotationen oder im Webflow (siehe <<SicherheitNutzerdok>>). Es kann auch jederzeit auf das Bean Sicherheit zugegriffen werden, um einen Berechtigungsmanager zu verwenden.

[source,java]
----
Berechtigungsmanager manager = sicherheit.getBerechtigungsManager();
manager.pruefeRecht(RechteSchluessel.RECHT_MELDEN);
----

Über die Methoden des Berechtigungsmanagers (z.B. `hatRecht`, `pruefeRecht`) kann die Anwendung
die Autorisierung durchführen.

[[überwachung]]
== Überwachung

In diesem Abschnitt wird beschrieben, wie die Überwachung einer Anwendung realisiert wird.

[[designvorgaben-11]]
=== Designvorgaben

* Die Überwachungsschnittstelle wird per JMX angeboten.
* Die MBeans werden gemäß der Namenskonvention aus <<UeberwachungKonfigKonzept>> benannt.
* MBeans enthalten keine Anwendungslogik.
Keinesfalls darf fachliche Logik in MBeans implementiert werden.
Allenfalls werden hier einfache Berechnungen (Durchschnittsbildung, Summierung usw.) durchgeführt.
* MBeans enthalten keine Management-Logik.
Die `MBeans` sind einfache Datencontainer für Management-Informationen.
`MBeans` sind dazu da, einem übergeordneten Management-System die zur Administration notwendigen
Informationen zu liefern.
Insbesondere wird in den MBeans keine Überwachungslogik implementiert.
* Business-Logik ruft Management-Logik.
Der Anwendungskern und die MBean werden von einer Spring-Factory erzeugt.
Der Anwendungskern ruft Methoden der MBean auf (Push-Konzept).
* Das Management-Interface darf nur die für Open MBeans erlaubten Datentypen für Parameter oder
Rückgabewerte verwenden.
+
NOTE: Eine vollständige Liste dieser Typen ist in <<UeberwachungKonfigKonzept>> enthalten.
* Die von Anwendungen bereitzustellenden Informationen sind in <<UeberwachungKonfigKonzept>> aufgeführt.
* Jede Anwendung muss eine Service-Operation anbieten, die es nutzenden Nachbarsystemen erlaubt,
die Erreichbarkeit dieses Systems zu prüfen (`Ping`-Methode).
* In jeder Anwendung wird ein Watchdog realisiert, welcher in regelmäßigen Abständen den Status des Systems prüft.
Dazu ruft er eine Prüf-Methode der Anwendung auf.
Der Aufruf der Prüf-Methode prüft den Status des Systems und aktualisiert das Ergebnis in der MBean.
* Die Prüf-Methode darf nur intern von einem Watchdog aufgerufen werden.
Sie darf weder als Service-Methode, noch per JMX von „außen“ aufrufbar sein.

[[klassendesign-5]]
=== Klassendesign

:desc-image-berwachung: Klassendesign für die Überwachung
[id="image-berwachung",reftext="{figure-caption} {counter:figures}"]
.{desc-image-berwachung}
image::Ueberwachung.png[align="center"]


<<image-berwachung>> zeigt das Klassendesign für die Anwendungsüberwachung.

Sie besteht zum einen aus der Service-Statistik, welche über die Klasse `ServiceStatistikMBean` angeboten wird.
Diese wird per AOP beim Aufrufen einer Methode der `RemoteBean` aktualisiert (siehe <<klassendesign-2>>).

Zum anderen wird für die Überwachung eine Ping-Methode implementiert und als Service-Methode in der Admin-Komponente angeboten.
Die Prüf-Methode wird in `AdminImpl` implementiert.
Diese darf auf keinen Fall als Service-Methode angeboten werden.

[[realisierung-11]]
=== Realisierung

[[einbinden-der-bibliothek-5]]
==== Einbinden der Bibliothek

Zur Realisierung der Überwachung muss die in <<table-Bibfdueber>> aufgelistete Bibliothek eingebunden werden.

:desc-table-Bibfdueber: Bibliothek für die Überwachung
[id="table-Bibfdueber",reftext="{table-caption} {counter:tables}"]
.{desc-table-Bibfdueber}
[cols=",",options="header"]
|====
|GroupId |ArtifactId
|de.bund.bva.isyfact |isy-ueberwachung
|====

Die Bibliothek enthält `MBeans`, welche das von Anwendungen bereitzustellende Management-Interface implementieren.

[[konfiguration-der-überwachungsschnittstelle]]
==== Konfiguration der Überwachungsschnittstelle

Zum Anbieten der Service-Statistik sind alle benötigten Implementierungen in „isy-ueberwachung“ enthalten.
Es muss lediglich die Spring-Konfiguration durchgeführt werden.
Diese besteht aus zwei Teilen, welche in <<UeberwachungKonfigKonzept>> im Detail beschrieben sind:

* Anbieten der MBeans über den Spring-MBean-Exporter.
* Anbinden der Zähl-Methode an den Anwendungskern durch einen AOP-Advice.
Dieser Advice wird so konfiguriert, dass bei jedem Aufruf einer Methode der RemoteBean
(siehe <<klassendesign-2>>) die Zähl-Methode der Statistik-MBean aufgerufen wird.

[[implementierung-der-ping--und-prüf-methoden]]
==== Implementierung der Ping- und Prüf-Methoden

Um die Verfügbarkeit bzw.
Erreichbarkeit eines Systems automatisiert überprüfen zu können, muss eine Ping- und eine Prüf-Methode in der
Komponente „Administration“ implementiert werden.

Die Ping-Methode wird per HttpInvoker als Service-Methode angeboten (siehe <<anbieten-von-service-schnittstellen>>).
Die Implementierung besteht darin, einfach den übergebenen String zurückzugeben.

Die Prüf-Methode darf nicht als Service-Methode angeboten, sondern muss intern von einem Watchdog regelmäßig
aufgerufen werden.
Die Prüf-Methode muss für jedes System individuell implementiert werden.
Als Grundsatz soll darin die Verfügbarkeit jedes Nachbarsystems und die aller genutzter Ressourcen
(z.B. Datenbank) geprüft werden.


[[konfiguration-des-watchdogs]]
==== Konfiguration des Watchdogs

Der Watchdog wird per Spring konfiguriert - es ist keine Implementierung erforderlich.
Eine Anleitung dafür ist in <<UeberwachungKonfigKonzept>> enthalten.

[[ldap-zugriff]]
== LDAP-Zugriff

In diesem Abschnitt wird beschrieben, wie LDAP-Zugriffe in einer Anwendung realisiert werden.
Dies kann notwendig sein, wenn ein Zugriff auf Daten notwendig ist, die noch nicht über eine querschnittliche Bibliothek oder einen Querschnittsdienst (z.B. Schlüsselverzeichnis) angeboten werden.

Für die Realisierung der LDAP-Zugriffe wird Spring-LDAP verwendet.
Daher muss die in <<table-BibfdSprLD>> aufgelistete Bibliothek eingebunden werden, sofern diese noch nicht wegen vorhandener Abhängigkeiten durch Maven geladen wird.

:desc-table-BibfdSprLD: Bibliothek für Spring-LDAP
[id="table-BibfdSprLD",reftext="{table-caption} {counter:tables}"]
.{desc-table-BibfdSprLD}
[cols=",",options="header",]
|====
|GroupId |ArtifactId
|org.springframework |spring-ldap
|====

[[spring-konfiguration]]
=== Spring Konfiguration

In der Spring-Konfigurationsdatei müssen drei Einträge für die Nutzung von Spring LDAP gesetzt werden:

:desc-listing-KonfSpring: Konfigurationsdatei für Spring
[id="listing-KonfSpring",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-KonfSpring}
[source,java]
----
<bean id="contextSource" class="org.springframework.ldap.pool.factory.PoolingContextSource">
<property name="contextSource">
<bean class="org.springframework.ldap.core.support.LdapContextSource">
<property name="url" value="${ldap.url}" />
<property name="userDn" value="${ldap.userdn}" />
<property name="password" value="${ldap.password}" />
<property name="base" value="${ldap.basedn}" />
<property name="pooled" value="false" />
</bean>
</property>
<property name="dirContextValidator">
<bean class="org.springframework.ldap.pool.validation.DefaultDirContextValidator" />
</property>
<property name="maxActive" value="${ldap.maxActive}" />
<property name="maxTotal" value="${ldap.maxTotal}" />
<property name="maxIdle" value="${ldap.maxIdle}" />
<property name="minIdle" value="${ldap.minIdle}" />
<property name="maxWait" value="${ldap.maxWait}" />
<property name="whenExhaustedAction" value="${ldap.whenExhaustedAction}" />
<property name="testOnReturn" value="${ldap.testOnReturn}" />
<property name="testOnBorrow" value="${ldap.testOnBorrow}" />
<property name="testWhileIdle" value="${ldap.testWhileIdle}" />
<property name="timeBetweenEvictionRunsMillis" value="${ldap.timeBetweenEvictionRunsMillis}" />
<property name="numTestsPerEvictionRun" value="${ldap.numTestsPerEvictionRun}" />
<property name="minEvictableIdleTimeMillis" value="${ldap.minEvictableIdleTimeMillis}" />
</bean>
<bean id="ldapTemplate" class="org.springframework.ldap.core.LdapTemplate">
<constructor-arg ref="contextSource" />
</bean>
<bean id="ldapTemplateHolder"
class="bva.bund.de.testdurchstich.springldap.LdapTemplateHolder">
<property name="ldapTemplate" ref="ldapTemplate" />
</bean>
----

In der Bean vom Typ `LdapContextSource` werden die zum Zugriff auf den LDAP benötigten Parameter definiert.
Diese Bean wird so konfiguriert, dass sie kein Pooling durchführt (`pooled = false`). Andernfalls würde der LDAP-Pool des JDKs verwendet, welcher keine Prüfung von Verbindungen erlaubt und somit nach einem Failover des LDAPs defekte Verbindungen im Pool behält.

Anstelle des JDK-Pools wird die Implementierung von Spring verwendet.
Dazu wird die `LdapContextSource`-Bean durch eine `PoolingContext`-Source-Bean gekapselt.
Letztere führt das Pooling der LDAP-Verbindungen durch.
In dieser Bean wird folglich auch der Pool konfiguriert, insbesondere das Prüfen der
Verbindungen vor deren Verwendung (`testOnBorrow = true`).

Die Bean `ldapTemplate` definiert die Klasse, die den Zugriff auf den LDAP kapselt, sie benötigt nur
die Bean `contextSource` als Parameter.

[[realisierung-12]]
=== Realisierung

LDAP-Zugriffe sind keine eigene Bibliothek, daher wird im Folgenden eine DAO-Klasse
vorgestellt, welche einen lesenden und schreibenden Zugriff auf einen LDAP zeigt.
Der hier gezeigte Code umfasst das Auslesen der Rollen eines Benutzers sowie das Anlegen
eines neuen Anwenders.
Es wird exemplarisch gezeigt, wie über das `LdapTemplate` Suchen und Einfügen in den
LDAP funktioniert.

[[auslesen-von-rollen]]
==== Auslesen von Rollen

:desc-listing-AusRollen: exemplarisch: Auslesen von Rollen
[id="listing-AusRollen",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-AusRollen}
[source,java]
----
public List<String> getRollen(String uid, String orgknz) {
  AndFilter filter = new AndFilter();
  filter.and(new EqualsFilter("uid", uid));
  filter.and(new EqualsFilter("orgknz", orgknz));
  List alleTreffer = LdapTemplateHolder.getLdapTemplate().
  search(DistinguishedName.EMPTY_PATH, filter.encode(), new RollenContextMapper());
  if (alleTreffer == null || alleTreffer.size() == 0) {
    throw new MyPlisTechnicalRuntimeException("Kein Benutzer gefunden");
  }
  return (List<String>)alleTreffer.get(0);
}

private static class RollenContextMapper extends AbstractContextMapper {
 public Object doMapFromContext(DirContextOperations ctx) {
    List<String> ergebnis = new ArrayList<String>();
    String[] rollen = ctx.getStringAttributes("rollen");
    for (String rolle : rollen) {
      ergebnis.add(rolle);
    }
    return ergebnis;
  }
}
----

Aufgerufen wird in diesem Beispiel die obere Methode mit `uid` (User-ID) und orgknz (Organisationskennzeichen) eines Anwenders, womit ein Anwender eindeutig identifiziert ist.

In den ersten drei Zeilen wird die Suchbedingung definiert, wobei `uid` und `orgknz` die Namen der entsprechenden Felder im LDAP sind.

In dem Block dahinter wird über den `LdapTemplateHolder` das `LdapTemplate` geholt, und auf diesem
die Methode `search` aufgerufen.
Dieser Methode wird zuerst ein einschränkender Pfad übergeben, dann die Suchbedingung und danach die
Abbildungsregel für das Ergebnis.
Als einschränkender Pfad wird eine Konstante für den leeren Pfad übergeben, die Suchbedingung haben
wir definiert und als Abbildungsregel wird eine neue Instanz von `RollenContextMapper` verwendet.
Das Ergebnis der Suche wird dann zurückgegeben.
Falls es zu keinem Treffer gekommen ist, wird eine Exception geworfen.

Die Klasse `RollenContextMapper` definiert das Abbilden von LDAP-Attributen auf Java-Objekte.
Die Methode `doMapFromContext` wird einmal für jeden gefundenen Treffer aufgerufen, der übergebene Context enthält alle Werte des Treffers und zusätzliche Metainformationen.
In unserer Klasse werden alle Rollen (Inhalt des LDAP-Attributes `rollen`) des Benutzers ausgelesen und als Liste zurückgegeben.

Zusammengefasst sucht diese Methode einen Benutzer, der durch seinen Anmeldenamen und sein Behörden-/Organisationskennzeichen identifiziert wird, und gibt die Rollen des Benutzers als Liste von Strings zurück.

[[speichern-eines-anwenders]]
==== Speichern eines Anwenders

Als Beispiel zum Speichern wird hier das Neuanlegen eines Anwenders gezeigt.

Die Klasse Anwender ist ein reines Transportobjekt mit Getter- und Setter- Methoden und wird nicht weiter erläutert.


:desc-listing-SpeichAnw: exemplarisch: Speichern eines Anwenders
[id="listing-SpeichAnw",reftext="{listing-caption} {counter:listings}"]
.{desc-listing-SpeichAnw}
[source,java]
----
public void speicherAnwender(Anwender anwender) {
  Name dn = buildDn(anwender);
  DirContextAdapter adapter = new DirContextAdapter(dn);
  adapter.setAttributeValues("objectclass", new String[] {"top", "person", "organizationalperson", "anwender"});
  adapter.setAttributeValue("cn", anwender.getBenutzerName());
  adapter.setAttributeValue("sn", anwender.getNachName());
  adapter.setAttributeValue("orgknz", anwender.getOrgknz());
  adapter.setAttributeValues("rollen", anwender.getRollen());
  adapter.setAttributeValue("uid", anwender.getUid());
  adapter.setAttributeValue("passwort", "InitialPasswort");
  adapter.setAttributeValue("status", "gueltig");
  LdapTemplateHolder.getLdapTemplate().bind(dn, adapter, null);
}

private Name buildDn(Anwender anwender) {
  DistinguishedName name = new DistingusishedName();
  name.add("o", anwender.getOrganisation());
  name.add("ou", anwender.getBehoerde());
  name.add("cn", anwender.getBenutzerName());
  return name;
}
----

In der ersten Zeile der Methode wird die Methode `buildDn` aufgerufen, die den Distinguished-Name des
Objektes zusammenbaut.
Der Distinguished-Name dient zur eindeutigen Identifizierung eines Anwenders, sein Aufbau ist vom Schema
des LDAP abhängig.

In den weiteren Zeilen wird ein Context-Adapter mit den Werten des Anwenders befüllt, wobei
jeweils angegeben werden muss, welches LDAP-Attribut mit welchem Wert befüllt wird.
Bei der Befüllung muss darauf geachtet werden, dass alle Pflichtattribute der angegebenen
Objektklassen gesetzt werden, das Attribut `objectclass` ist immer Pflicht.

In der letzten Zeile der Methode wird wiederum das `LdapTemplate` aufgerufen und mit der
Methode `bind` ein neuer Eintrag im LDAP angelegt.
Als erster Parameter wird der DN des Eintrags mitgeliefert, in den Parametern zwei und drei werden alle zu
setzenden Attribute übergeben, entweder als Context oder als Sammlung von Attributen.
