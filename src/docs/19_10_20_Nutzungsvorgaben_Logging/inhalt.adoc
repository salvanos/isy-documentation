[[grundlagen]]
= Grundlagen

In diesem Kapitel sind die Grundlagen des Loggings beschrieben.

[[grundprinzipien-des-loggings]]
== Grundprinzipien des Loggings

Im Folgenden werden zunächst die Grundprinzipien des Loggings beschrieben, die den nachfolgenden Kapiteln zu Grunde liegen und das Logging in der IsyFact geprägt haben.
Diese sollen ein einheitliches Verständnis und „Gefühl“ für das Logging vermitteln.

*Logs als Ereignisdatenbank:* Logdateien werden häufig als einfache Textdateien verstanden, in die Einträge – vergleichbar mit der Ausgabe von Text in der Konsole – hinzugefügt werden.
Zur Umsetzung eines effizienten Loggings müssen die Logs jedoch vielmehr als Ereignisdatenbank verstanden werden, in die wichtige Ereignisse über die komplette Anwendungslandschaft hinweg aufgenommen werden, um Analysen bzgl.
des Verhaltens der Systeme und von wichtigen Systemereignissen zu ermöglichen.
Das Schreiben eines Logeintrags darf daher explizit nicht wie das Schreiben eines Fließtextes in eine Logdatei verstanden werden, sondern wie das Speichern eines Ereignisses in einer Datenbank.
Daher gelten die Prinzipien:

****
.  *Logeinträge als Ereignis der Anwendung begreifen*
.  *Logging als Backend – wie eine Datenbank – begreifen*
****

*Zielgerichtetes Logging:* Logging muss zielgerichtet erfolgen, d.h. das Schreiben eines Logeintrags erfolgt zu einem bestimmten Zweck.
Logeinträge, die von niemandem ausgewertet werden, sind überflüssig.
Logeinträge, die nicht die relevanten Informationen enthalten, um sinnvoll ausgewertet werden zu können, sind unbrauchbar.
Daher gelten die Prinzipien:

****
[start=3]
.  *Definiere den Zweck*: Für jeden Logeintrag muss klar sein, zu welchem Zweck dieser erstellt wird.
.  *Formuliere Ausgaben für einen konkreten Anwendungsfall**: Das Erstellen eines Logeintrags erfolgt für einen konkreten Anwendungsfall, in dem der Logeintrag später genutzt wird.
Die Inhalte des Logeintrags müssen alle Informationen enthalten, so dass dieser Anwendungsfall effizient ausgeführt werden kann.
.  *Definiere den Konsumenten*: Für jeden Logeintrag muss klar sein, wer der Konsument des Logeintrags ist – also durch welchen Akteur der Eintrag später ausgewertet wird.
Dies wird erreicht, in dem jedem Anwendungsfall ein Akteur zugeordnet ist, durch den er ausgeführt wird.
.  *Verwende nur Ausgaben, die auch ausgewertet werden*: Logeinträge sind nur dann sinnvoll, wenn sie später auch ausgewertet werden.
Logeinträge, die nicht ausgewertet werden (Selbstzweck), sind zu vermeiden.
****

*Logging als Funktionalität der Anwendungen*: Logausgaben sind Teil der Funktionalität der Anwendung und daher gilt:

****
[start=7]
. *Logging muss qualitätsgesichert werden*: Logeinträge der Log-Level INFO, WARN, ERROR und FATAL müssen (analog zur fachlichen Funktionalität der Anwendung) einem Review unterzogen werden.
****

[[kennzeichnung-von-logeinträgen]]
== Kennzeichnung von Logeinträgen

Jeder Logeintrag wird mit einem Log-Level gekennzeichnet.
Darüber hinaus werden Logeinträge bestimmter Level zusätzlich mit einer Log-Kategorie und einem Ereignisschlüssel gekennzeichnet, um die maschinelle Auswertung der Logeinträge zu erleichtern.
Die zugrundeliegenden Konzepte werden in den folgenden Abschnitten erläutert.
Die in <<logszenarien>> beschriebenen Szenarien treffen konkrete Vorgaben, wann welche Ausprägungen zu verwenden sind.

[[log-level]]
=== Log-Level

Jeder Logeintrag wird bei seiner Erstellung mit einem Log-Level gekennzeichnet.
Dieses dient der Klassifizierung des Logeintrags im Hinblick auf dessen Wichtigkeit.
Die Wichtigkeit ergibt sich dabei insbesondere aus dem Einfluss des geloggten Ereignisses auf den Systembetrieb.
Darüber hinaus wird der Log-Level zur Steuerung der Granularität der erzeugten Logausgaben verwendet.
So kann das Log-Level bspw.
auf INFO gestellt werden, wodurch nur noch Logeinträge der gleichen Kategorie oder darunter (WARN, ERROR; FATAL) erzeugt werden.
Die folgenden Log-Level haben sich dabei im Java-Umfeld etabliert und werden auch in der IsyFact eingesetzt:

:desc-table-loglevel: Log-Level
[id="table-loglevel",reftext="{table-caption} {counter:tables}"]
.{desc-table-loglevel}
[cols="1,4,8,8",options="header"]
|====
|# |Level |Inhalt |Beispiel(e)
|1 |FATAL |Schwerwiegende Fehler, von denen sich die Anwendung nicht erholen kann und beendet
werden muss ("Unrecoverable Error"). Es ist ein Eingreifen des Betriebs notwendig, um die
Anwendung wieder zu starten.
a|
Die Eingabe-Datei eines Batchs kann nicht gelesen werden und der Batch muss beendet werden.

OutOfMemoryError.

|2 |ERROR |Fehler, die zum Abbruch einer Operation geführt haben und behandelt (gefangen und nicht weitergereicht) wurden.
Die Anwendung läuft weiter.
Der Betrieb muss die Fehlerursache analysieren und ggf.
Gegenmaßnahmen einleiten, um ein erneutes Auftreten des Fehlers zu verhindern.
a|
Nachbarsystem ist endgültig nicht erreichbar.

Datenbank ist nicht erreichbar.

Fehlerhafter Satz wurde gelesen.

|3 |WARN |Beim Durchführen einer Operation ist ein Problem aufgetreten.
Die Operation wurde jedoch grundsätzlich durchgeführt.
Der Betrieb muss im Hinblick auf die Fehleranalyse hierbei (zunächst) nicht aktiv werden. |Aufruf eines Nachbarsystems muss wiederholt werden.
|4 |INFO |(Status-) Hinweise a|
Meldungen über den laufenden Betrieb, zum Beispiel zu verarbeiteten Anfragen, ihrem Ergebnis und ihrer Dauer, Anwendung gestartet/beendet

Durchführung eines Retries (bspw.
auf Grund eines OptimisticLocking-Fehlers)

|5 |DEBUG |Erweiterte Informationen, um Details im Programmablauf zur Fehleranalyse nachvollziehen zu können. |Meldungen zu markanten Verarbeitungsschritten (bspw. „ Führe Suche nach Personen durch“)
|6 |TRACE |Feingranulare und umfangreiche Informationen als Ergänzung des DEBUG-Levels für besonders schwierige Fehleranalysen. |Vollständige HTTP-Kommunikation an einer Schnittstelle (Header, Body, technische Informationen).
|====

[underline]#Hinweis zum Log-Level FATAL#: SLF4J und damit auch logback (welches `isy-logging`zugrunde liegt)
besitzen kein Log-Level FATAL.
Die Unterscheidung, ob ein Error-Logeintrag „fatal“ ist oder nicht, kann mit Hilfe von Markern umgesetzt
werden.

NOTE: Siehe auch bei http://slf4j.org/faq.html#fatal

`isy-logging` stellt Methoden zum Schreiben von Logeinträgen
im Level ERROR als auch in FATAL bereit.
Bei beiden wird ein Logeintrag im Level ERROR erzeugt, dieser aber je nach verwendeter Methode mit der
Kategorie „FATAL“ oder „ERROR“ versehen.
Das Log-Level FATAL kann aus Sicht eines Aufrufers von `isy-logging` daher wie alle anderen Level
verwendet werden.
Bei der Auswertung ist auf diese Besonderheit jedoch zu achten.

[[ausgabe-des-log-levels-fatal]]
==== Ausgabe des Log-Levels FATAL

Das Log-Level FATAL wird ist durch SLF4J nicht vorgesehen und wird daher auch durch logback nicht unterstützt.
Aus diesem Grund werden Logeinträge die im Level FATAL geschrieben werden, im Level ERROR in die Logdatei geschrieben und mit einer entsprechenden Log-Kategorie (FATAL bzw.
ERROR) versehen (siehe auch nachfolgender Abschnitt)

[[log-kategorien]]
=== Log-Kategorien

Log-Kategorien dienen der Klassifizierung der Logeinträge im Hinblick auf deren Zweck.
Dies erleichtert die maschinelle Auswertung der Logs und ermöglicht es, gezielt Logeinträge einer Kategorie gesondert zu behandeln (bspw.
deren Ausgabe umzuleiten oder zu verwerfen). Die Log-Kategorien stellen dabei Verfeinerungen der Log-Level dar.
Log-Kategorien werden ausschließlich im Level INFO verwendet und werden in folgender Tabelle beschrieben:

:desc-table-UnterLogKat: Unterscheidung der Log-Kategorien
[id="table-UnterLogKat",reftext="{table-caption} {counter:tables}"]
.{desc-table-UnterLogKat}
[cols="<2,<3,<9,<7",options="header"]
|====
|Level |Kategorie |Beschreibung |Beispiel(e)
.2+.^|ERROR |FATAL |Logeinträge des Log-Levels FATAL (vgl.
<<ausgabe-des-log-levels-fatal>>) |_siehe Log-Level FATAL_
    |ERROR |Logeinträge des Log-Levels ERROR (vgl.
<<ausgabe-des-log-levels-fatal>>) |_siehe Log-Level ERROR_
.4+.^|INFO |JOURNAL |Informationen zu Systemzustand, Systemereignissen und durchgeführten Operationen.
a|
Herunterfahren des Systems,

Änderung der Konfiguration
 |PROFILING |Informationen zum Laufzeitverhalten des Systems. |Dauer der Verarbeitung eines Nachbarsystem­aufrufs
 |METRIK |Kennzahlen zum Systembetrieb und zur Systemnutzung. |Erfolgreiche/Fehler­hafte Nutzung einer Service-Methode
 |SICHERHEIT |(Potentieller) Angriffsversuch. |Benutzer-Account wird gesperrt wegen zu vieler ungültiger Anmeldeversuche
|====

[[ereignisschluessel]]
=== Ereignisschlüssel

Ereignisschlüssel dienen der _eindeutigen_ Identifikation des Zwecks, auf Grund dessen der Logeintrag im Log-Level INFO erstellt wurde (bspw.
Erstellung eines Logeintrags beim Verlassen einer Systemgrenze zur Performancemessung). Dies ist notwendig, da das Log-Level INFO eine Vielzahl unterschiedlicher Auswertungs­möglichkeiten bietet.
Ohne die Verwendung des Schlüssels könnte der Zweck des jeweiligen Eintrags meist nur mit Kenntnis des Quellcodes oder Interpretation der Lognachricht ermittelt werden, was eine maschinelle Auswertung der Einträge erschwert oder gar unmöglich macht.

Wenn an mehreren Stellen Logeinträge für den gleichen Zweck erstellt werden, wird hierfür der gleiche Ereignisschlüssel verwendet.
Dies ist bspw.
im Logszenario „Loggen fachlicher Operationen“ (siehe <<loggen-fachlicher-operationen>>) der Fall, in dem die Durchführung fachlicher Operationen jeweils mit dem gleichen Ereignisschlüssel geloggt werden, so dass alle diese Einträge mit einer einzelnen Abfrage auf den definierten Schlüssel ausgewertet werden können.

In den Log-Leveln FATAL, ERROR und WARN wird der jeweilige Fehlerschlüssel als Ereignisschlüssel verwendet.
In den Log-Leveln DEBUG und TRACE werden keine Ereignisschlüssel Verwendet, da dort der Zweck bereits eindeutig durch den Log-Level (Zweck „Fehleranalyse“) bestimmt ist.
Dadurch kann der Aufwand für die Verwendung der Ereignisschlüssel gering gehalten werden.

In <<ereignisschluessel-isy-logging>> wird eine Reihe von Standardschlüsseln definiert, die durch das Logging-Framework verwendet werden.
Darüber hinaus können in jeder Anwendung eigene Ereignisschlüssel, für systemspezifische Zwecke, definiert werden.

Der Aufbau der Ereignisschlüssel entspricht dem folgenden Schema:

[frame="none"]
|====
^|`E[A-Z]\{5}[0-9]\{2}[0-9]\{3}`
|====

Dieses setzt sich aus den folgenden Elementen zusammen:

* Jedem Schlüssel wird die feste Zeichenkette „**E**“ vorangestellt, um den Eintrag als Ereignisschlüssel
zu Kennzeichnen und zu verhindern, dass dieser mit Fehler- oder Hinweisschlüsseln verwechselt wird.
* *5 Buchstaben*, zur Identifikation des Systems.
Diese ist analog zur Identifikation, die auch bei den Ausnahme-IDs (siehe <<FehlerbehandlungKonzept>>) verwendet wird.
+
Anmerkung: Die Systemidentifikation ist Teil des Ereignisschlüssels, um sicherzustellen, dass
systemspezifische / bibliotheksspezifische Schlüssel nicht in mehreren Komponenten redundant vergeben werden.
* *2 Ziffern*, zur eindeutigen Identifikation der Komponente, in der der Logeintrag erstellt wird (Komponenten-ID). Bei der Erstellung einer neuen Anwendung ist in der Spezifikations- bzw.
Konstruktionsphase festzulegen, welche Komponente welche ID zugeordnet wird.
Dies ist ebenfalls analog zur Definition der Ausnahme-IDs – es wird für Ausnahme-IDs und Ereignisschlüssel die gleiche Komponenten-ID verwendet.
* *3 Ziffern*, als laufende Nummer der Ereignisschlüssel der jeweiligen Komponente.

Ein exemplarischer Ereignisschlüssel der Fachanwendung XYZ ist demnach:

[frame="none"]
|====
^|`EXYZFA12123`
|====

Der Aufbau des Ereignisschlüssels besitzt darüber hinaus explizit keine weitere Semantik, um Redundanzen mit den weiteren Attributen des Logeintrags zu vermeiden.

[[vorgaben-fuer-logdateien]]
== Vorgaben für Logdateien

Jede Applikation schreibt _eine_ einzelne Logdatei.
Weitere Logdateien sind nicht erlaubt.
Ausnahmen bilden Logdateien, die durch den Container geschrieben werden, z.B. ein Wrapper- oder Access-Log eines Tomcat-Servers.

[[namenskonventionen1]]
=== Namenskonventionen

Die Logdateien haben fest vorgegebene Namen, die dem folgenden Namensschema entsprechen:

[frame="none"]
|====
^|`<HOST>_<SYSTEM-ID>_<ZEITSTEMPEL>.log`
|====

Die einzelnen Platzhalter im Namensschema sind in folgender Tabelle beschrieben:


:desc-table-logdatname: Bestandteile eines Logdateinamens
[id="table-logdatname",reftext="{table-caption} {counter:tables}"]
.{desc-table-logdatname}
[cols="2,3,2",options="header"]
|====
|Bestandteil |Werte |Beschreibung
|HOST |z.B. xyzweb01 |Name des Servers, auf dem die Logs entstehen
|SYSTEM-ID |_Durch den Technischen Chefdesigner für die jeweilige Anwendung
in Abstimmung mit dem Auftraggeber festzulegen siehe <<Namenskonventionen>>._ a|Name der Anwendung bzw. des Batches.
_Anwendung bezieht sich hierbei auf die Anwendungen, die im Tomcat laufen, in Abgrenzung zu Batches._
|ZEITSTEMPEL |YYYY-MM-DD_HH00 |Datum der Logdateien inkl.
stundengenauer Uhrzeit.
Zu beachten ist, dass der Zeitstempel erst beim Rotieren der Logs an die Datei angehängt
wird (siehe <<log-rotation-und-komprimierung>>).
|LAUFENDE-NUMMER |1, 2, 3 … |Bei Batches wird ein größenbasiertes Rollieren der Logdateien
durchgeführt (siehe <<log-rotation-und-komprimierung>>). Diese werden dabei mit einer laufenden Nummer versehen.
|====

Ein Beispiel des Namens einer Logdatei ist demnach:

[frame="none"]
|====
^a|`xyzweb01_xyzfachverfahren_2007-09-16_0900.log` +
(Log vom 16. September 2007 ~9 Uhr, von der Anwendung XYZ-Fachverfahren auf dem Server xyzweb01)

`xyzweb01_batchxyz_1.log` +
(Rollierte Logdatei des Batches XYZ-Batch auf dem Server xyzweb01)
|====

[[speicherort]]
=== Speicherort

Um die Logdateien durch die Infrastruktur möglichst einfach weiterverarbeiten zu können, werden Logdateien in einem definierten Logverzeichnis je Host abgelegt, welches Unterverzeichnisse für jede Anwendung besitzt.
Diese Verzeichnishierarchie ist für alle Anwendungen und Umgebungen gleich, um den Pflegeaufwand für diese Aufgabe so gering wie möglich zu halten.

Logdateien müssen entsprechend dem folgenden Schema abgelegt werden:

[frame="none"]
|====
^a|`/var/log/<SYSTEM-ID>/<LOGDATEI>`
|====

Bei der Einführung einer neuen Anwendung ist die System-ID (Anwendungsname/Batch-ID) entsprechend abzustimmen und der Betrieb darüber in Kenntnis zu setzen.

[[log-rotation-und-komprimierung]]
=== Log-Rotation und Komprimierung

Um zu verhindern, dass Logdateien zu groß werden und es gleichzeitig zu ermöglichen, die Logdateien nur für bestimmte Fristen vorzuhalten, werden die anfallenden Logeinträge stündlich in neue Dateien geschrieben (rollierendes Logging).

Zu beachten ist, dass für den Zeitstempel der rotierten Logdateien die Zeitzone UTC verwendet wird – analog zum Zeitstempel der einzelnen Logeinträge.
Dieser kann von der Systemzeit des Systems abweichen.

[underline]#Sonderfall: Batches#

Für Batches wird eine größenbasierte Rotation (100MB) durch das Logging-Framework umgesetzt.
Ein Batch erzeugt demnach pro Lauf potentiell mehrere Logdateien unabhängig von dessen Dauer.

Anmerkung: Es findet keine Komprimierung der Logdateien durch das Logging-Framework statt.
Hintergrund ist, dass die Komprimierung bei Batches nicht eingesetzt werden kann und ein einheitlicher
Mechanismus für alle Logdateien umgesetzt werden soll.
Bei den Batches ist eine Komprimierung nicht möglich, da die Komprimierung durch das Logging-Framework
erst beim Rollieren der Logdatei erfolgt.
Beim Ausführen des Batches wird die zuletzt angefangene Logdatei jedoch nicht mehr rolliert und damit
auch nicht komprimiert.

[[einsatz-des-logging-frameworks]]
= Einsatz des Logging-Frameworks

In diesem Abschnitt wird der Einsatz des Logging-Frameworks `isy-logging` beschrieben.

[[aufruf-des-frameworks]]
== Aufruf des Frameworks

Zur Erstellung von Logeinträgen gibt es drei Schnittstellen, die jeweils ein spezifisches Anwendungsszenario
umsetzen: `IsyLoggerStandard`, `IsyLoggerFachdaten` und `IsyLoggerTypisiert`.
Wird innerhalb einer Klasse mehr als ein Anwendungsszenario verwendet, kann die Schnittstelle `IsyLogger`
verwendet werden, welche alle drei Schnittstellen umfasst.

Jede Klasse, in der Logs geschrieben werden, muss eine eigene Logger-Instanz verwenden.
Es ist nicht vorgesehen Logger zu vererben.
Die Erzeugung der Logger-Instanz erfolgt mit der Logger-Factory, die durch `isy-logging` bereitgestellt wird.

[source,java]
----
public class MyClass {
...
private static final IsyLogger LOG = IsyLoggerFactory.getLogger(MyClass.class);
... oder ...
private static final IsyLoggerStandard LOG = IsyLoggerFactory.getLogger(MyClass.class);
... oder ...
private static final IsyLoggerFachdaten LOG = IsyLoggerFactory.getLogger(MyClass.class);
... oder ...
private static final IsyLoggerTypisiert LOG = IsyLoggerFactory.getLogger(MyClass.class);
...
}
----

Der Name des Loggers muss dem Namen der Klasse entsprechen, in welcher der Logger instanziiert wird – dazu wird die Klasse beim Aufruf der Factory übergeben.
Dies ist notwendig, um Logeinträge ihrer Quelle zuordnen zu können.

Zwar stellt der Logger eine Vielzahl von Methoden bereit, allerdings unterscheidet sich der Aufruf kaum von den üblichen Methoden anderer Frameworks – die Vielzahl der Methoden ergibt sich primär durch die Bereitstellung unterschiedlich typisierter Methoden zum Loggen von Ausnahmen, datenschutzrelevanter Daten und der Verwendung von Markern.

[underline]#Anmerkungen#

* Die Schnittstelle bietet nicht alle bzw. andere Methoden an, als bspw.
SLF4J oder log4j.
Dies ist beabsichtigt, um die Log-Inhalte in Systemen, die gemäß der IsyFact entwickelt werden, besser
standardisieren zu können.
Drittsoftware (bspw.
Frameworks wie Hibernate, Spring etc.) oder Systeme, die schrittweise auf das Logging-Framework
migriert werden, nutzen automatisch die Logger-Schnittstelle, die durch logback bereitgestellt
wird (zum Umgang mit Drittsoftware siehe <<performance-logging>>, zur Migration
siehe <<anhaenge.adoc#migration-von-log4j-auf-isy-logging>>).
* Die Logeinträge werden beim Schreiben einheitlich mit einem Zeitstempel der Zeitzone „UTC“ versehen.
Hierauf kann beim Aufruf des Loggers keinen Einfluss genommen werden.

[[loggen-von-technischen-daten]]
=== Loggen von technischen Daten

Zum Loggen von technischen und nicht datenschutzrelevanten Daten bietet `isy-logging` die Schnittstelle
`IsyLoggerStandard` an. <<image-SS-IsyLoggerStandard>> zeigt eine Übersicht der Schnittstelle:

:desc-image-SS-IsyLoggerStandard: Schnittstelle `IsyLoggerStandard`
[id="image-SS-IsyLoggerStandard",reftext="{figure-caption} {counter:figures}"]
.{desc-image-SS-IsyLoggerStandard}
image::SS-IsyLoggerStandard.png[align="center"]

[[loggen-einfacher-nachrichten-tracedebugwarninfo]]
==== Loggen einfacher Nachrichten (TRACE/DEBUG/WARN/INFO)

Die folgenden Methoden dienen der _einfachen_ Ausgabe von Lognachrichten:

[source,java]
----
trace(String nachricht, Object... werte)
debug(String nachricht, Object... werte)
warn(String schlussel, String nachricht, Object... werte)
info(LogKategorie kategorie, String schlussel, String nachricht, Object... werte)
----
Der Aufruf wird an die entsprechende Methode des SLF4J-Loggers (mit gleicher Signatur) delegiert.
Dabei werden alle werte (d.h. die Inhalte für Platzhalter in der Nachricht) zusätzlich als Marker übergeben,
so dass sie im Logeintrag als separate Attribute ausgegeben werden können und damit einfacher auswertbar sind:

* `parameter1`: werte[1].
* `parameter2`: werte[2].
* etc.

Beispiel: Der Aufruf

[source,java]
----
debug("Die Methode {} wurde mit dem Parameter {} aufgerufen.", "addiere", "5")
----

ergänzt die folgenden Attribute im Logeintrag:

* `parameter1`: addiere
* `parameter2`: 5

[[loggen-von-ausnahmen-fatalerrorwarninfo]]
==== Loggen von Ausnahmen (FATAL/ERROR/WARN/INFO)

In den Log-Leveln FATAL, ERROR und WARN existieren je drei Methoden zum Loggen von Exceptions:

* `<fatal/error/warn>(String nachricht, PlisException exception, Object... werte)`
* `<fatal/error/warn>(String nachricht, PlisTechnicalRuntimeException exception, Object... werte)`
* `<fatal/error/warn>(String schluessel, String nachricht, Throwable exception, Object... werte)`

Für das Log-Level INFO wird zusätzlich eine Log-Kategorie benötigt.
Beim Loggen einer IsyFact-eigenen Ausnahme wird der Fehlerschlüssel automatisch als Ereignisschlüssel übernommen.
Bei anderen Ausnahmen muss zusätzlich ein Ereignisschlüssel übergeben werden.

Der Aufruf wird an die entsprechende Methode des SLF4J-Loggers delegiert.
Als Marker werden dabei übergeben:

* `fehlerschluessel`: Fehlerschlüssel der `PlisException`.

* `parameter[1..n]`: siehe oben (<<loggen-einfacher-nachrichten-tracedebugwarninfo>>)

[[loggen-von-informationen-info]]
==== Loggen von Informationen (INFO)

Zum Erstellen von INFO-Logeinträgen wird die folgende Methode bereitgestellt:

* `info(LogKategorie kategorie, String schluessel, String nachricht, Object... werte)`

Der Aufruf wird an die entsprechende Methode des SLF4J-Loggers delegiert.
Als Marker werden dabei übergeben:

* `kategorie`: Mit dem Wert des übergebenen Parameters
* `schluessel`: Mit dem Wert des übergebenen Parameters

* `parameter[1..n]`: siehe oben (<<loggen-einfacher-nachrichten-tracedebugwarninfo>>)

[[loggen-datenschutzrelevanter-daten]]
=== Loggen datenschutzrelevanter Daten

Lognachrichten dürfen im Allgemeinen keine datenschutzrelevanten (d.h. fachlichen) Daten enthalten.
Unter Umständen kann es jedoch notwendig sein, entsprechende Daten in den Logeintrag mitaufzunehmen, um
die in <<auswertungen>> definierten Auswertungen zu ermöglichen (Beispiel: Eine Fehleranalyse ist nur
 mit Kenntnis der an der Schnittstelle übertragenen Daten möglich). Diese Logeinträge müssen bei
 ihrer Erstellung markiert werden, so dass sie durch die Log-Infrastruktur speziell geschützt
 werden können.

Zum Loggen datenschutzrelevanter Daten bietet `isy-logging` die Schnittstelle `IsyLoggerFachdaten` an.
<<image-SS-IsyLoggerFachdaten>> zeigt eine Übersicht der Schnittstelle:

:desc-image-SS-IsyLoggerFachdaten: Schnittstelle `IsyLoggerFachdaten`
[id="image-SS-IsyLoggerFachdaten",reftext="{figure-caption} {counter:figures}"]
.{desc-image-SS-IsyLoggerFachdaten}
image::SS-IsyLoggerFachdaten.png[align="center"]

Zu allen Methoden, die in <<loggen-von-technischen-daten>> beschrieben wurden, bietet die Schnittstelle
`IsyLoggerFachdaten` eine äquivalente Methode mit gleicher Signatur an, die zum Loggen von
datenschutzrelevanten fachlichen Daten im jeweiligen Log-Level verwendet wird.
Die Methoden tragen dabei jeweils das Suffix „Fachdaten“ im Namen.

[[verwendung-von-markern-in-logeinträgen]]
=== Verwendung von Markern in Logeinträgen

Zum beliebigen Markieren von Logeinträgen bietet `isy-logging` die Schnittstelle `IsyLoggerTypisiert` an.
<<image-SS-IsyLoggerTypisiert>> zeigt eine Übersicht der Schnittstelle:

:desc-image-SS-IsyLoggerTypisiert: Schnittstelle `IsyLoggerTypisiert`
[id="image-SS-IsyLoggerTypisiert",reftext="{figure-caption} {counter:figures}"]
.{desc-image-SS-IsyLoggerTypisiert}
image::SS-IsyLoggerTypisiert.png[align="center"]

Die in <<loggen-datenschutzrelevanter-daten>> beschriebene Funktionalität verwendet intern einen
festen Marker, um einen Logeintrag als datenschutzrelevant („Fachdaten“) zu kennzeichnen.
Die Schnittstelle `IsyLoggerTypisiert` ermöglicht es Anwendungen darüber hinaus, Logeinträge mit
beliebigen Markern zu versehen.

Zu allen Methoden, die in <<loggen-von-technischen-daten>> beschrieben wurden, bietet die
Schnittstelle `IsyLoggerTypisiert` eine äquivalente Methode mit gleicher Signatur an, die
zum Markieren der jeweiligen Logeinträge verwendet werden kann.
Die Methoden besitzen jeweils einen zusätzlichen Parameter vom Typ `IsyDatentypMarker`.
Anwendungen können ihre Marker von der Klasse `AbstractIsyDatentypMarker` ableiten.

[[verwendung-von-platzhaltern-in-nachrichten]]
=== Verwendung von Platzhaltern in Nachrichten

In den Lognachrichten können Platzhalter verwendet werden, die beim Erstellen des Logeintrags mit
 den konkreten Werten des aktuellen Aufrufs ersetzt werden (bspw.
gemessene Laufzeit).

Platzhalter sind in den Nachrichten durch geschweifte Klammern `{}` zu kennzeichnen, bspw.:

[source,java]
----
// RICHTIG:
LOG.debug("Die Methode {} wurde mit dem Parameter {} aufgerufen.", method.getName(), wert)
----

Die Verwendung des Parameters `werte` zum Ersetzen der Platzhalter ermöglicht es zudem, die übergebenen
Parameter als separate Attribute in den Logeintrag zu übernehmen (siehe vorhergehende Abschnitte), was
die Auswertbarkeit der Einträge erleichtert.
Zudem wird die Performance des Systems leicht erhöht, da die Konkatenation des Strings nur dann erfolgt,
wenn der Logeintrag auch geschrieben wird (d.h. der Log-Level eingeschaltet ist) – dieser
Performance-Gewinn ist jedoch vernachlässigbar und nicht die eigentliche Motivation dieser Vorgehensweise.

Das direkte Konkatenieren von Zeichenketten zum Aufbau einer Lognachricht ist nicht erlaubt:

[source,java]
----
//FALSCH:
LOG.debug("Die Methode " + method.getName() + " wurde mit dem Parameter " + wert + " aufgerufen.")
----

Das früher weitverbreitete `isDebugEnabled` ist im Normalfall nicht mehr notwendig (da die Konkatenation
durch logback nur stattfindet, wenn der Logeintrag auch geschrieben wird) und sollte daher auch nicht
mehr verwendet werden, um den Code übersichtlich zu halten:

[source,java]
----
//FALSCH:
if (LOG.isDebugEnabled()) {
  LOG.debug("Die Methode {} wurde mit dem Parameter {} aufgerufen.", method.getName(), wert).
}
----

Ausnahme ist hierbei jedoch das Loggen komplexer Meldungen:

[source,java]
----
//RICHTIG:
if (LOG.isDebugEnabled()) {
   LOG.debug("Debug-Meldung: {} ", myObject.complexMethod());
}
----

In diesem Code-Beispiel wird sehr viel Rechenzeit verbraucht, um die Log-Information von der
Methode `myObject.complexMethod()` zu bekommen.
Um den komplexen Aufruf nur durchzuführen, wenn der Logeintrag auch wirklich geschrieben wird,
ist es in diesem Fall sinnvoll die Prüfung `isDebugEnabled` durchzuführen.

[[hilfsklassen]]
=== Hilfsklassen

`isy-logging` stellt die folgenden Hilfsklassen zum Erstellen von Logeinträgen bereit.

[[loggingmethodinterceptor-und-loggingmethodinvoker]]
==== LoggingMethodInterceptor und LoggingMethodInvoker

Die Klassen `LoggingMethodInterceptor` und `LoggingMethodInvoker` bieten die Möglichkeit, einheitliche
Logeinträge vor und nach dem Aufruf einer Methode für verschiedene Zwecke (insbesondere dem Messen der
Laufzeit für das Profiling) zu erstellen.
Beide erzeugen die gleichen Logeinträge, dienen jedoch unterschiedlichen Einsatzzwecken.

Der Interceptor wird per Spring als Method-Interceptor konfiguriert und kann dadurch querschnittlich für
eingehende Methodenaufrufe konfiguriert werden – dies wird in <<logbackconfiglistener>> beschrieben.

Der Invoker wird direkt im Anwendungscode für die Durchführung von Methodenaufrufen verwendet.
Zur Verwendung des Invokers, muss eine Instanz des Interceptors als Klassenvariable erstellt werden:

[source,java]
----
public class MyClass {
private static final LoggingMethodInterceptor _LOG_INTERCEPTOR_ = new LoggingMethodInterceptor(true, true, false, false);
...
----

Der Konstruktor besitzt folgende Signatur:

* `LoggingMethodInvoker(Method methode, IsyLogger logger, boolean loggeAufruf, boolean loggeErgebnis, boolean
loggeDauer, boolean loggeDaten, boolean loggeDatenBeiException, long loggeMaximaleParameterGroesse)`: Methode
ist die aufzurufende Methode.
Die Flags werden verwendet, um zu steuern, welche Logeinträge erstellt werden (siehe unten).

Das Loggen eines Methodenaufrufs erfolgt mit der Methode:

* `fuehreMethodeAus(Object zielobjekt, Object... parameter)`: Ruft per Reflection die Methode, welche per
Konstruktor gesetzte wurde, auf dem Zielobjekt mit den übergebenen Parametern auf und schreibt die
Logeinträge mit folgenden Ereignisschlüsseln (Details zu den Inhalten der jeweiligen Logeinträge
finden sich in Kapitel <<ereignisschluessel-isy-logging>>):

:desc-table-ESLogMthdInvk: Ereignisschlüssel LoggingMethodInvoker
[id="table-ESLogMthdInvk",reftext="{table-caption} {counter:tables}"]
.{desc-table-ESLogMthdInvk}
[cols="^",options="header"]
|====
|Ereignisschlüssel LoggingMethodInvoker
|*Falls loggeAufruf = true*
<m|EISYLO01001
|*Falls loggeErgebnis = true und keine Exception geliefert wurde*
<m|EISYLO01002
|*Falls loggeErgebnis = true und eine Exception geliefert wurde*
<m|EISYLO01003
|*Falls loggeDauer = true und keine Exception geliefert wurde*
<m|EISYLO01004
|*Falls loggeDauer = true und eine Exception geliefert wurde*
<m|EISYLO01005
|====

Darüber hinaus werden folgende Debug-Logeinträge erstellt:

:desc-table-DbgLogEntry: Debug Logeinträge
[id="table-DbgLogEntry",reftext="{table-caption} {counter:tables}"]
.{desc-table-DbgLogEntry}
[cols="^2,^1,2,4",options="header"]
|====
|Schlüssel |Level |Kategorie |Text
4+|*Falls loggeDatenBeiException = true*
| |DEBUG | a| Die <Klasse. Methode> wurde mit folgenden Parametern aufgerufen <Parameter>.

ANMERKUNG: Der Logeintrag wird als „Fachdaten“ gekennzeichnet.
4+^|*Falls loggeDaten = true und eine Exception geliefert wurde*
| |DEBUG | a| Die <Klasse. Methode> wurde mit folgenden Parametern aufgerufen <Parameter>.

ANMERKUNG: Der Logeintrag wird als „Fachdaten“ gekennzeichnet.
4+^|*Falls Debug-Einträge erstellt werden und ein Parameter zu groß ist*
| |DEBUG | a| Die <Klasse. Methode> wurde mit einem zu großen Parameter aufgerufen.
Position: <Position des Parameters>, Klasse: <Klasse des Parameters>

ANMERKUNG: Der Logeintrag wird als „Fachdaten“ gekennzeichnet. Außerdem werden zu große Parameter
in den oben genannten Logeinträgen durch „<Maximale Größe überschritten>“ ersetzt.
|====

Den Aufrufen von Nachbarsystemen kommt eine besondere Wichtigkeit bei der Analyse des Laufzeitverhaltens von Systemen zu.
Daher stellt der Invoker für Methodenaufrufe von Nachbarsystemen einen eigenen Konstruktor bereit:

* `LoggingMethodInvoker(Method methode, IsyLogger logger, boolean loggeAufruf, boolean loggeErgebnis,
boolean loggeDauer, boolean loggeDaten, boolean loggeDatenBeiException , long
loggeMaximaleParameterGroesse, String nachbarsystemName, String nachbarsystemUrl)`: Analog zu oben,
nur das der Name und die URL des aufgerufenen Nachbarsystems übergeben wird.

Dieser Konstruktor ist beim Aufruf einer Serviceschnittstelle eines Nachbarsystems zu verwenden (vgl.
auch Szenario „Performance überwachen“ in <<performance-ueberwachen>>). Zu beachten ist, dass die
Klasse `IsyHttpInvokerClientInterceptor`, welche durch den Baustein Service bereitgestellt
wird (siehe <<ServiceDetailkonzept>>), bereits einen entsprechenden Aufruf des Invokers durchführt.
Bei Verwendung dieses Konstruktors werden die Logeinträge mit folgenden Ereignisschlüsseln erstellt:

:desc-table-ESLogMthdInvkNSAufr: Ereignisschlüssel LoggingMethodInvoker (Nachbarsystemaufruf)
[id="table-ESLogMthdInvkNSAufr",reftext="{table-caption} {counter:tables}"]
.{desc-table-ESLogMthdInvkNSAufr}
[cols="^",options="header"]
|====
|Ereignisschlüssel LoggingMethodInvoker (Nachbarsystemaufruf)
|*Falls loggeAufruf = true*
<m|EISYLO01011
|*Falls loggeErgebnis = true und keine Exception geliefert wurde*
<m|EISYLO01012
|*Falls loggeErgebnis = true und eine Exception geliefert wurde*
<m|EISYLO01013
|*Falls loggeDauer = true und keine Exception geliefert wurde*
<m|EISYLO01014
|*Falls loggeDauer = true und eine Exception geliefert wurde*
<m|EISYLO01015
|====

[[logapplicationlistener]]
==== LogApplicationListener

Die Hilfsklasse `LogApplicationListener` dient dem Loggen von Änderungen des Systemzustands.
Sie muss gemäß <<logapplicationlistener-1>> als Spring-Bean konfiguriert, aber danach nicht mehr explizit
aufgerufen werden.
Die Klasse erstellt die Logeinträge mit folgenden Ereignisschlüsseln (Details zu den Inhalten der
jeweiligen Logeinträge finden sich in <<ereignisschluessel-isy-logging>>):

:desc-table-ESLogAppLstn: Ereignisschlüssel LogApplicationListener
[id="table-ESLogAppLstn",reftext="{table-caption} {counter:tables}"]
.{desc-table-ESLogAppLstn}
[cols="^",options="header"]
|====
|Ereignisschlüssel LogApplicationListener
|*Beim Starten einer Anwendung / eines Batches*
<|`EISYLO02001`, `EISYLO02003` und je ein Eintrag mit Schlüssel `EISYLO02004` für die folgenden
Parameter: Java-Version, Zeitzone, Heap-Size, File-Encoding
|*Beim Stoppen einer Anwendung / eines Batches*
<m|EISYLO02002
|====

[[mdchelper]]
==== MdcHelper

Die Klasse MdcHelper erleichtert das Setzen von Informationen im MDC (Mapped Diagnostic Context).

Es werden Methoden zum Setzen und Lesen der Korrelations-ID bereitgestellt:

* pushKorrelationsId(…): Zum „pushen“ einer neuen Korrelations-ID in den MDC.
Dies bedeutet: Wenn die Korrelations-ID „X“ gesetzt wird, wird diese im Attribut „korrelationsid“ im MDC gesetzt.
Sollte dieses Attribut bereits gesetzt sein (bspw.
mit der Korrelations-ID „Y“), so wird das Attribut durch „Y;X“ ersetzt.
* `liesKorrelaiionsId()`: Liest die Korrelations-ID aus dem MDC.
* `entferneKorrelationsId()`: Entfernt die zuletzt „gepushte“ Korrelations-ID (bspw. „Y;X“ wird zu „Y“).
* `entferneKorrelationsIds()`: Entfernt alle Korrelations-IDs.
+
Darüber hinaus werden Methoden zum Kennzeichen der Inhalte im MDC als fachlich bereitgestellt (vgl.
Abschnitt <<loggen-datenschutzrelevanter-daten>>):
* `setzeMarkerFachdaten(...)`: Markiert den MDC als fachlich / nicht fachlich.
* `liesMarkerFachdaten()`: Gibt an, ob der MDC fachliche Daten enthält.
* `entferneMarkerFachdaten()`: Entfernt den Marker für Fachdaten.

[[diagnosekontext-korrelations-id]]
=== Diagnosekontext / Korrelations-ID

Die Korrelations-ID (siehe <<ServicekommunikationKonzept>>) ist in jedem Eintrag mitzuloggen, damit die Logeinträge
einzelnen Aufrufen zugeordnet und über die Komponenten der Anwendungslandschaft verfolgt werden können.
Das Ermitteln der Korrelations-ID erfolgt automatisch durch `isy-logging`.
Hierzu wird der Mapped Diagnostic Context (MDC) verwendet, der durch SLF4J bzw.
logback zur Verfügung gestellt wird.
Der MDC wird über eine statische Methode gesetzt, und zwar pro Thread:

 MDC.put("Korrelations-ID", "<Korrelations-ID>");

Die Korrelations-ID kann sich aus mehreren Unique-IDs zusammensetzen, durch die der Aufruf durch die
Anwendungslandschaft nachverfolgt werden kann.
Die IDs müssen hintereinander gehängt, getrennt durch ein Semikolon, im Kontext gesetzt werden, bspw.:

 MDC.put("Korrelations-ID", "c15638a2-4c38-4d18-b887-5ebd2a1c427d;f60143b3-3408-4501-9947-240ec1c48667;c893d44f-3b8e-446e-a360-06a520440e64");

Am Ende der Verarbeitung ist der MDC wieder zu entfernen:

 MDC.remove("Korrelations-ID");

*Anmerkung zu Multi-Threading*

Es wird davon ausgegangen, dass es innerhalb eines Request kein Multi-Threading gibt, sondern nur in den Clients.
Da der Client einem bestimmten Benutzer zugeordnet werden kann, wird hier kein MDC benötigt.

Sollte jedoch Multi-Threading innerhalb eines Requests vorhanden sein, so ist der MDC dem Thread mitzugeben.
Somit müssen alle Klassen, die das Interface Runnable implementieren, eine Methode vorsehen, um den MDC von der
Klasse zu bekommen, die den Thread startet.
Ansonsten besitzt der gestartete Thread nicht den Kontext des aufrufenden Threads.
Zusätzlich muss im Thread eine weitere Unique-ID an die Korrelations-ID im MDC angehängt werden, so dass auch
die Logeinträge des Threads eindeutig identifiziert werden können.

[[konfiguration]]
== Konfiguration

In diesem Abschnitt werden die notwendigen Konfigurationen zum Einrichten des Loggings beschrieben.
Die Konfiguration erfolgt dabei ausschließlich über die Konfigurationsdatei von logback
und Spring – `isy-logging` besitzt selbst keine zusätzliche Konfigurationsdatei.

[[logback-konfiguration]]
=== Logback-Konfiguration

Folgende Aspekte sind bei der Logback-Konfiguration zu beachten:

[underline]#Konfigurationsdateien#

Alle Anwendungen dürfen ihre Logging-Konfiguration ausschließlich über die Konfigurationsdatei `logback.xml` vornehmen.
Die Auslieferung der Logging-Konfiguration geschieht mit den applikationsspezifischen Konfigurationsdateien für die jeweilige Umgebung.
Die Ablage der Konfigurationsdatei in Sourcen und Kompilaten ist durch das Konzept <<UeberwachungKonfigKonzept>> definiert.
Die Konfigurationsdateien dürfen nicht in einem Archiv (JAR-Bibliothek) abgelegt werden, sondern müssen als einzelne Dateien installiert werden.

[underline]#Log-Level und Anpassung der Konfiguration zur Laufzeit#

Logback wird so konfiguriert, dass die Konfigurationsdatei jede Minute automatisch neu geladen wird und durchgeführte Änderungen – ohne Neustart der Anwendung – übernommen werden.
In Testumgebungen kann hierdurch zwischen verschiedenen Konfigurationsalternativen gewechselt werden.
In Produktion ist die Konfiguration in aller Regel fix, da sie auf die betriebliche Infrastruktur abgestimmt sein muss.
In der Produktionsumgebung darf daher nur der Log-Level angepasst werden.

Standardmäßig werden die Systeme in Produktion im Log-Level INFO betrieben.
Bei Bedarf kann jedoch auf DEBUG und in Ausnahmefällen auf TRACE gewechselt werden, um detaillierte Informationen zur Fehleranalyse bereitzustellen.
Andere Log-Level sind zu vermeiden.

[[anwendungen-zeitbasiertes-rollieren]]
==== Anwendungen (zeitbasiertes Rollieren)

Die Bilbiothek `isy-logging`stellt bereits einen vorkonfigurierten Appender bereit, durch den Logdateien gemäß den
in <<vorgaben-fuer-logdateien>> definierten Vorgaben erstellt werden.
In der Anwendung selbst ist daher nur noch eine minimale Logging-Konfiguration notwendig:

[source,xml]
----
<configuration scan="true" scanPeriod="1 minutes">
<!-- Eindeutige mIdentifikation der Instanz der Anwendung. -->
<contextName>testserver_testsystem</contextName>
<!-- Pfad der Logdatei, ohne Endung -->
<property name="LOGFILE_PATH" value="logausgaben/testserver_testsystem" />
<!-- MDC in die Ausgabe mitaufnehmen. -->
<property name="INCLUDE_MDC" value="false" />
<!-- Include der vorkonfigurierten Appender. -->
<include resource="resources/isylogging/logback/appender.xml" />
<!-- Root-Logger als Grundlage für alle Logger-Instanzen -->
<root level="trace">
<appender-ref ref="DATEI_ANWENDUNG" />
</root>
</configuration>
----

Folgende Parameter sind zu setzen:

* `LOGFILE_PATH`: Der Pfad der Logdatei (LOGFILE_PATH) muss gemäß den Vorgaben aus Abschnitt 3.3 angepasst werden.
* `INCLUDE_MDC`: Gibt an, ob der komplette Inhalt des MDC in das Log aufgenommen werden soll (true) oder nicht (false).
* `CONTEXT_NAME`: Als `contextName` wird „<HOST>_<SYSTEM-ID>“ zur eindeutigen Identifikation der Instanz der Anwendung angegeben.

[[batches-größenbasiertes-rollieren]]
==== Batches (größenbasiertes Rollieren)

Die Konfiguration des Loggings für Batches erfolgt analog zum vorhergehenden Abschnitt.
Es wird jedoch ein anderer Appender referenziert der ein größenbasiertes Rollieren umsetzt:

[source,xml]
----
<configuration scan="true" scanPeriod="1 minutes">
<!-- Pfad der Logdatei, ohne Endung -->
<property name="LOGFILE_PATH" value="logausgaben/testserver_testsystem" />
<!-- MDC in die Ausgabe mitaufnehmen. -->
<property name="INCLUDE_MDC" value="false" />
<!-- Maximale Fenstergröße der zu erstellenden Logdateien. -->
<property name="MAX_INDEX" value="20" />

<!-- Include der vorkonfigurierten Appender. -->
<include resource="resources/isylogging/logback/appender.xml" />
<!-- Root-Logger als Grundlage für alle Logger-Instanzen -->
<root level="trace">
<appender-ref ref="DATEI_BATCH" />
</root>
</configuration>
----

Der Parameter `MAX_INDEX` muss Standardmäßig auf „20“ gesetzt werden.
Dieser wird im Folgenden erläutert:

Logback stellt die beiden Policies `TimeBasedRollingPolicy` und `FixedWindowRollingPolicy` zur Verfügung.
Erstere wird im referenzierten Appender DATEI_ANWENDUNG verwendet, letztere im Appender DATEI_BATCH,
um ein rein größenbasiertes Rollieren durchzuführen. `FixedWindow` bedeutet hierbei, dass immer nur
eine maximale Anzahl an Logdateien erhalten bleiben (gemäß der „Window-Größe“). Die Logdateien werden dabei mit einer laufenden Nummer versehen („Logdatei1“, „Logdatei2“ etc.). Beim Rollieren, wird die Nummer der vorhandenen Logdateien erhöht („Logdatei1“ wird „Logdatei2“ etc.) und die aktuelle Logdatei zu „Logdatei1“ umbenannt.
Bei einer Fenstergröße von 20 wird dabei die vorher ggf.
vorhandene „Logdatei20“ gelöscht. Da die Logdateien zwischen jedem Batchlauf archiviert werden,
ist eine Angabe der Fenstergröße aus
Sicht dieses Konzepts nicht notwendig – dies ist jedoch ein Pflichtparameter der logback-Konfiguration.
Standardmäßig muss der Wert auf 20 gesetzt werden.
Dieser Wert wurde gewählt, da es der Standardwert ist, und ein Batch in der Regel nicht mehr als
2 GB Logs erstellt (sollte dies doch der Fall sein, muss die Fenstergröße entsprechend erhöht werden).

[[lokale-entwicklungsumgebung-konsolenausgabe]]
==== Lokale Entwicklungsumgebung (Konsolenausgabe)

In der lokalen Entwicklungsumgebung ist es hilfreich, die Logausgaben direkt auf der Konsole in einem
einfachlesbaren Format auszugeben.
Hierfür wird folgende Konfiguration verwendet:

[source,xml]
----
<configuration scan="false">
<!-- Include der vorkonfigurierten Appender. -->
<include resource="resources/isylogging/logback/appender-entwicklung.xml" />
<!-- Root-Logger als Grundlage für alle Logger-Instanzen -->
<root level="trace">
<appender-ref ref="KONSOLE" />
</root>
</configuration>
----

[[weitere-konfigurationsmöglichkeiten]]
==== Weitere Konfigurationsmöglichkeiten

In diesem Abschnitt werden weitere Möglichkeiten der Konfiguration von logback beschrieben,
die bei Bedarf genutzt werden können:

[[logging-für-einzelne-klassen-deaktivieren]]
==== Logging für einzelne Klassen deaktivieren

Es kann sinnvoll sein, das Log-Level einer einzelnen Klasse oder eines Packages abweichend zum Root-Logger zu
konfigurieren – bspw. falls ein Framework in einer bestimmten Klasse irreführende Logeinträge erzeugt.
Dies geschieht nach folgendem Schema:

[source,xml]
----
<logger name="<Package- oder Klassenname>" level="<Log-Level>"
additivity="false">
<appender-ref ref="FILE" />
</logger>
<!-- Root-Logger als Grundlage für alle Logger-Instanzen -->
<root level="debug">
...
----

Das Attribut `additivity=false` gibt dabei an, dass für die konfigurierte Klasse bzw.
das konfigurierte Package ausschließlich dieser Logger und nicht zusätzlich der Root-Logger verwendet werden soll.

[[spring-konfiguration]]
=== Spring-Konfiguration

Im Folgenden werden die Spring-Konfigurationen zur Integration von logback in Spring und zur Konfiguration
der genutzten Hilfsmechanismen (vgl. <<konzeptlogging>>) beschrieben.

[[logbackconfiglistener]]
==== LogbackConfigListener

Zum Initialisieren und sauberen Herunterfahren von logback in Web-Anwendungen, wird der `LogbackConfigListener`
verwendet, der durch die Bibliothek `org.logback-extensions:logback-ext-spring` bereitgestellt wird.
Hierzu ist eine entsprechende Konfiguration in der web.xml vorzunehmen:

[source,xml]
----
<web-app>
...
<!--
Angabe des Speicherorts der logback Konfiguration
Wenn nicht angegeben, greift die Standardinitialisierung:
Konfiguration im Classpath.
Aufgrund des Deplyoments liegt die Konfiguration aber unter
/classes/config/logback.xml
-->
<context-param>
<param-name>logbackConfigLocation</param-name>
<param-value>classpath:/config/logback.xml</param-value>
</context-param>
<!--
Angabe des zu verwendenden Listeners fuer logback
Dies ist noetig, da Container, die die Servlet 2.4 API implementieren
verlangen, dass Listener vor load-on-startup Servlets geladen werden.
Servlet 2.3 Container erzwingen dieses Vorgehen.
Ausserdem ist der LogbackConfigListener vor dem ContextLoaderListener zu
registrieren, siehe analoge Vorgaben für log4j
unter http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/web/util/Log4jConfigListener.html
Anmerkung: Sollte ein aelterer Servlet-Container (2.2) verwendet werden ist
LogbackConfigServlet anstelle von LogbackConfigListener zu verwenden.
-->
<listener>
<listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>
</listener>
<!--
Bootstrap Listener zum Starten des Springs Haupt-WebApplicationContexts
von Spring.
Delegiert an ContextLoader.
Sofern der Log4jConfigListener verwendet wird ist dieser Listener danach
in der web.xml zu registrieren.
Anmerkung: Sollte ein aelterer Servlet-Container (2.2) verwendet werden ist
ContextLoaderServlet anstelle von ContextLoaderListener zu verwenden.
-->
<listener>
<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener> +
...
</web-app>
----

[[loggingmethodinterceptor]]
==== LoggingMethodInterceptor

Der `LoggingMethodInterceptor` besitzt die folgenden Konfigurationsparameter:

`loggeDauer`, `loggeAufruf`, `loggeErgebnis`, `loggeDaten`, `loggeDatenBeiException` und `loggeMaximaleParameterGroesse`
(vgl. <<loggingmethodinterceptor-und-loggingmethodinvoker>>).

Es werden zwei Instanzen des LogInterceptors mit unterschiedlichen Ausprägungen der oben genannten
Parameter konfiguriert:

* `boundaryLogInterceptor`: Dieser wird verwendet, um Aufrufe an Systemgrenzen zu loggen.
Es müssen entsprechende Pointcuts für alle Service-Schnittstellen, GUI-Controller und Batchausführungsbeans
definiert werden (siehe Szenarien in <<aufruf-an-systemgrenze>> und <<rueckliefern-einer-exception-an-systemgrenze>>).
* `komponentLogInterceptor`: Dieser wird verwendet, um Aufrufe an Komponentengrenzen zu loggen.
Es müssen entsprechende Pointcuts für alle relevanten Komponenten-Schnittstellen definiert werden
(siehe Szenario in Abschnitt 5.2.2.3).

Die Konfiguration der Beans ist im Folgenden dargestellt:

[source,xml]
----
<beans ...>
<!-- Autoproxies einschalten -->
<aop:aspectj-autoproxy />
<!-- Interceptor zum Loggen an Systemgrenzen. -->
<bean id="boundaryLogInterceptor" class="de.bund.bva.isyfact.logging.util.LoggingMethodInterceptor">
<property name="loggeDauer">
<value>${isylogging.boundary.loggeDauer}</value>
</property>
<property name="loggeAufruf">
<value>${isylogging.boundary.loggeAufruf}</value>
</property>
<property name="loggeErgebnis">
<value>${isylogging.boundary.loggeErgebnis}</value>
</property>
<property name="loggeDaten">
<value>${isylogging.boundary.loggeDaten}</value>
</property>
<property name="loggeDatenBeiException">
<value>${isylogging.boundary.loggeDatenBeiException}
</value>
</property>
<property name="loggeMaximaleParameterGroesse">
<value>${isylogging.boundary.loggeMaximaleParameterGroesse}
</value>
</property>
</bean>
<!-- Interceptor zum Loggen an Komponentengrenzen. -->
<bean id="componentLogInterceptor" class="de.bund.bva.isyfact.logging.util.LoggingMethodInterceptor">
<property name="loggeDauer">
<value>${isylogging.component.loggeDauer}</value>
</property>
<property name="loggeAufruf">
<value>${isylogging.component.loggeAufruf}</value>
</property>
<property name="loggeErgebnis">
<value>${isylogging.component.loggeErgebnis}</value>
</property>
<property name="loggeDaten">
<value>${isylogging.component.loggeDaten}</value>
</property>
<property name="loggeDatenBeiException">
<value>${isylogging.component.loggeDatenBeiException}
</value>
</property>
<property name="loggeMaximaleParameterGroesse">
<value>${isylogging.component.loggeMaximaleParameterGroesse}
</value>
</property>
</bean>
<!-- AOP-Advice für das Logging konfigurieren -->
<aop:config>
<!-- Pointcuts an den Systemgrenzen -->
<aop:advisor order="1000" advice-ref="boundaryLogInterceptor"
pointcut="target(de.bund.bva.xyz.fachanwendungxyz.service.meldung.httpinvoker.v1_0.MeldungRemoteBean)
or target(de.bund.bva.xyz.fachawendungxyz.gui.meldung.MeldungController)" />
<!-- Pointcuts an den Komponentengrenzen -->
<aop:advisor order="1000" advice-ref="componentLogInterceptor"
pointcut="target(de.bund.bva.xyz.fachawendungxyz.core.meldung.Meldung)" />
</beans>
----

[WARNING]
====
Folgende Aspekte müssen zwingend beachtet werden:

* Jeder definierte Advisor belegt ca. 5 MB im Heap Space.
Damit die Anzahl der Advisor gering gehalten wird, wird für jeden Interceptor nur ein Advisor
definiert und die verschiedenen `targets` mit `or` verbunden.
Analog zum Pointcut an den Systemgrenzen im obigen Beispiel.
* Die Werte der Konfigurationsparameter (`isylogging.boundary.loggeDauer`, `isylogging.boundary.loggeAufruf` etc.)
müssen als betriebliche Konfigurationsparameter in der Anwendungskonfiguration abgelegt werden
und wie folgt gesetzt werden:
====

:desc-table-ESIsyLog: Ereignisschlüssel isy-logging
[id="table-ESIsyLog",reftext="{table-caption} {counter:tables}"]
.{desc-table-ESIsyLog}
[cols="6m,2m,6",options="header"]
|====
|Parameter |Default |Bemerkung
|isylogging.boundary.loggeDauer |true .3+|Muss auf `true` sein, um das Logszenario _Aufruf an Systemgrenze_
umzusetzen.
|isylogging.boundary.loggeAufruf |true
|isylogging.boundary.loggeErgebnis |true
|isylogging.boundary.loggeDaten |false |Kann in einer Testumgebung oder temporär in Produktion auf `true`
gesetzt werden, um die gesamte Schnittstellenkommunikation zur Unterstützung der Fehlersuche auszugeben.
|isylogging.boundary.loggeDatenBeiException |true |Muss auf `true` sein, um das Logszenario _Rückliefern
einer Exception an Systemgrenze_ umzusetzen.
|isylogging.boundary.loggeMaximaleParameterGroesse |0 a|
Setzt die maximale Größe von Parametern, die ins Log geschrieben werden dürfen, in Bytes.

Ist nur aktiv, wenn `loggeDaten` oder `loggeDatenBeiException` auf `true` gesetzt ist.

0 bedeutet keine Beschränkung.
|isylogging.component.loggeDauer |false .2+|Die Ausgabe der Dauer und der durchgeführten Aufrufe an
Komponentengrenzen führt zu einem hohen Logvolumen.
Daher ist es sinnvoll, den Parameter im Produktivbetrieb nur bei Bedarf auf v zu stellen (vgl.
Logszenario _Aufruf an Komponentengrenze_).
|isylogging.component.loggeAufruf |false
|isylogging.component.loggeErgebnis |false .3+|Kann in einer Testumgebung oder temporär in Produktion zur
Unterstützung der Fehlersuche `true` gesetzt werden.
|isylogging.component.loggeDaten |false
|isylogging.component.
loggeDatenBeiException |false
|isylogging.component.
loggeMaximaleParameterGroesse |0 a|
Setzt die maximale Größe von Parametern, die ins Log geschrieben werden dürfen, in Bytes.

Ist nur aktiv, wenn loggeDaten oder loggeDatenBeiException auf `true` gesetzt ist.

0 bedeutet keine Beschränkung.
|====

[underline]#*Anpassen der Konvertierung*#

Ist der Parameter `loggeDatenBeiException` auf `true` gesetzt, werden die übergebenen Schnittstellenparameter der Methode, bei der eine Exception aufgetreten ist, falls sie nicht zu groß sind oder die Größenbeschränkung deaktiviert ist, konvertiert (serialisiert) und in den Logeintrag übernommen.
Handelt es sich bei einem der Parameter um eine Objektstruktur, wird diese Struktur teilweise rekursiv durchlaufen und sämtliche Attribute in den Logeintrag übernommen.
Bei dieser Konvertierung gelten standardmäßig folgende Regeln:

* Sämtliche Objekte im Package `de.bund.bva` (inkl.
Subpackages) werden rekursiv durchlaufen.
* Alle anderen Objekte, Primitives und Enums werden mit `toString` umgewandelt.

Dieses Verhalten [underline]#*kann*# bei Bedarf konfigurativ angepasst werden, in dem die beiden Constructor-Argumente
`converterIncludes` und `converterExcludes` angegeben werden.
Dabei gilt:

* Alle Objekte aus Packages (und Sub-Packages) in der Liste `converterIncludes` werden Rekursiv durchlaufen.
* Alle Objekte aus Packages (und Sub-Packages) in der Liste `converterExcludes` werden ignoriert.
* Alle anderen Objekte werden mit `toString` umgewandelt.

Gründe für die Anpassung der Konfiguration können bspw.
sein:

* Exkludieren einzelner Packages, die nicht serialisiert werden können oder nicht relevant sind und dadurch zu unnötigen Loginhalten führen.
* Inkludieren einzelner Packages, falls die Anwendung nicht in der Domäne de.bund.bva entwickelt wird.

Eine exemplarische Konfiguration ist im Folgenden dargestellt:

[source,xml]
----
<!-- Interceptor zum Loggen an Systemgrenzen. -->
<bean id="xyzInterceptor" class="de.bund.bva.isyfact.logging.util.LoggingMethodInterceptor">
<constructor-arg name="converterIncludes">
<list>
<!-- included Packages -->
<value>x.y.z</value>
</list>
</constructor-arg>
<constructor-arg name="converterExcludes">
<list>
<!-- excluded Packages -->
<value>a.b.c</value>
</list>
</constructor-arg>
…
</bean>
----

[[logapplicationlistener-1]]
==== LogApplicationListener

Im Folgenden wird die Konfiguration des LogApplicationListener dargestellt:

[source,xml]
----
<beans ...>
<bean id="statusLogger"
class=" de.bund.bva.isyfact.logging.util.LogApplicationListener">
<property name="systemart"
value="<SYSTEMART>" />
<property name="systemname"
value="<SYSTEMNAME>" />
<property name="systemversion"
value="${<VERSIONSNUMMER>}" />
</bean>

</beans>
----

Die Platzhalter müssen dabei wie folgt ersetzt werden:

* `SYSTEMART`: Kürzel der Systemart gemäß den Namenskonventionen (siehe ) – bspw.
`REG` bei einem Register, `GA` bei einer Geschäftsanwendung, `QK` bei einer Querschnittskomponente,
`BAT` bei einem Batch.
* `SYSTEMNAME`: Name der Anwendung analog zu <<anwendungen-zeitbasiertes-rollieren>>.
* `VERSIONSNUMMER`: Versionsnummer der Anwendung.
Diese ist als interner Konfigurationsparameter in der Anwendung abzulegen.

[[performance-logging]]
=== Performance-Logging

In diesem Abschnitt werden die notwendigen Konfigurationen zum Einrichten des Performance-Loggings beschrieben.

Die Auswahl der zu loggenden Aufrufe erfolgt über die Namenskonventionen von IsyFact.
Eine Übersicht über die erfassten Klassen bietet die folgende Tabelle:

[cols="2,4a",options="header"]
|====
|Schicht / Klassen |Pointcut
|Controller / Webaufrufe a| `public *  *..gui..*Controller.*(..)`
|Serviceschicht | `public * *..service..*ServiceImpl.*(..)`
|Core-Komponenten | `public * *..core..*Impl.*(..)`
|AWF-Klassen | `* * ..core..Awf*.*(..)`
|AFU-Klassen | `* * ..core..Afu*.*(..)`
|DAOs | `public * *..persistence..*DaoImpl.*(..)`
|====

Bei allen Aufrufen wird nur die Dauer des Aufrufs geloggt.

[[einbinden-der-spring-konfiguration]]
==== Einbinden der Spring-Konfiguration

Zum Aktivieren des Performance-Logging wird eine durch `isy-logging` bereitgestellte Spring-Konfiguration
eingebunden:

[source,xml]
----
<beans ...>
...
<import resource="classpath:resources/isylogging/spring/aop-performance-logging.xml"/> +
...
</**beans**>
----

Diese Konfiguration ist nach dem Einbinden über das Spring-Profil `performance-logging` zu aktivieren.

[[annotation-fuer-performance-logging]]
==== Annotation für Performance-Logging

Für den Fall, dass Aufrufe außerhalb der Namenskonventionen geloggt werden sollen, wird die Annotation `@PerformanceLogging`
bereitgestellt.
Damit werden Methoden annotiert, die vom Performance-Logging erfasst werden sollen.
So können z.B. auch die Aufrufe fremder RemoteBean-Schnittstellen geloggt werden.

[[umgang-mit-drittsoftware]]
=== Umgang mit Drittsoftware

Es muss sichergestellt werden, dass alle Bibliotheken – auch solche die nicht nach den Vorgaben der IsyFact entwickelt
wurden – logback, mit der in <<logback-konfiguration>> definierten Konfiguration, nutzen.
Dadurch wird gewährleistet, dass die definierten Vorgaben zu Logdateien und Struktur der Logeinträge einheitlich
 umgesetzt werden.

Beim Einsatz von Bibliotheken, die nicht nach der IsyFact entwickelt wurden, muss daher unterschieden werden:

* **Die Bibliothek loggt mittels logback oder SLF4J**: Es sind keine Maßnahmen notwendig.

* **Die Bibliothek setzt ein anderes Logging-Framework ein**: Es muss eine entsprechende „Bridge“ integriert werden,
welche die Aufrufe der Bibliothek an das jeweilige Logging-Framework auf logback umleitet.

SLF4J stellt bereits fertige Bridges für alle gängigen Logging-Frameworks zur Verfügung, deren Einsatz im Folgenden
beschrieben wird.
Grundsätzlich ist es unkritisch, wenn alle Bridges konfiguriert werden.
Um die Komplexität der Konfiguration und deren Wartung nicht unnötig zu erhöhen, sollten jedoch nur die Bridges
eingerichtet werden, die auch tatsächlich benötigt werden.

Bei sämtlichen Bridges muss sichergestellt werden, dass das `logback.jar` als einzige SLF4J-Implementierung in der
Anwendung vorhanden ist.

[[bridge-für-log4j]]
==== Bridge für log4j

SLF4J stellt mit der Bibliothek `log4j-over-slf4j.jar` eine Bridge von log4j zu slf4j zur Verfügung.
Diese kann wie folgt eingesetzt werden:

.  `log4j*.jar` aus der Anwendung entfernen (bzw.
sicherstellen, dass diese durch Maven nicht in die Anwendung integriert werden)
.  `log4j-over-slf4j.jar` in die Anwendung ergänzen

[[bridge-fuer-commons-logging]]
==== Bridge für commons-logging

Analog zu log4j in <<einbinden-der-spring-konfiguration>>, nur dass die Bibliothek `jcl-over-slf4j.jar` verwendet wird.

[[bridge-fuer-java.util.logging]]
==== Bridge für java.util.logging

SLF4J stellt für die java.util.logging API ebenfalls eine Bridge zur Verfügung (jul-to-slf4j.jar).
Um die Bridge zu aktivieren müssen zunächst alle vorhandenen Log-Handler entfernt und danach ein Handler
zum Weiterleiten der Log-Aufrufe an SLF4J installiert werden.

NOTE: Weitere Informationen über SLF4J unter http://www.slf4j.org/api/org/slf4j/bridge/SLF4JBridgeHandler.html

Diese kann wie folgt umgesetzt werden:

. `jul-to-slf4j.jar` in die Anwendung ergänzen
. Den folgenden Abschnitt in die Spring-Konfiguration der Anwendung ergänzen:

[source,xml]
----
<!-- Bridge von java.util.logging nach SLF4J einrichten-->
<!-- 1. Entferne vorhandene Log-Handler -->
<bean id="slf4JBridgeHandler" class="org.slf4j.bridge.SLF4JBridgeHandler"
init-method="removeHandlersForRootLogger"/>
<!-- 2. Installiere den Handler der Bridge -->
<bean class="org.slf4j.bridge.SLF4JBridgeHandler"
init-method="install"
depends-on="slf4JBridgeHandler"/>
----

[[vorgaben-zur-logerstellung]]
= Vorgaben zur Logerstellung

Die Zielsetzung des Loggings ist es, unterschiedliche Auswertungen zu ermöglichen, um damit verschiedene Problemstellungen und Informationsbedarfe, die während des Betriebs der Systeme entstehen, einfach und effizient beantworten zu können.
Grundlage hierfür bildet zum einen die technische Vereinheitlichung des Loggings, die in den vorangegangen Abschnitten (Nutzung und Konfiguration) beschrieben wurde.
Zum andern muss das Logging jedoch insbesondere auch inhaltlich – also _wann_ wird _was_ geloggt – einheitlich und zielgerichtet im Hinblick auf die verschiedenen Auswertungen erfolgen.
Dadurch wird sichergestellt, dass die Logeinträge einfach ausgewertet werden können und alle notwendigen Informationen vorliegen.

Aus diesem Grund werden im folgenden Abschnitt zunächst die verschiedenen Auswertungen beschrieben, die für alle Anwendungen relevant sind.
Bei Entwurf eines Systems können systemspezifische Anforderungen definiert werden, die analog zu den hier aufgeführten Themen adressiert werden müssen.
Es ist Aufgabe des Technischen Chefdesigners diese Anforderungen im Rahmen des Systementwurfs abzustimmen und zu berücksichtigen.

Die konkreten Szenarien, in denen Logeinträge zu erstellen sind, werden in <<logszenarien>> definiert.

[[auswertungen]]
== Auswertungen

In diesem Abschnitt werden Auswertungen beschrieben, die auf den Logs der Anwendungslandschaft durchgeführt werden können müssen.
Die Auswertung erfolgt dabei meist durch den Betrieb und nicht durch die Entwickler.
Es ist jedoch Aufgabe der Entwickler sämtliche Informationen in den Logs bereitzustellen, so dass die Szenarien effizient durchgeführt werden können.

Es wird zwischen folgenden Akteuren unterschieden:

* Betrieb: Mitarbeiter der IT-Abteilung, in der das System bzw.
die Anwendungslandschaft betrieben wird.
* Entwickler: Mitarbeiter der Entwicklungsabteilung, durch die die Anwendung entwickelt, gewartet und/oder weiterentwickelt wird.
* Fachbereich: Mitarbeiter des Fachbereichs / der Fachabteilung, durch die die Anwendung fachlich betreut und geführt wird.

[[schwerwiegenden-fehler-erkennen-und-behandeln]]
=== Schwerwiegenden Fehler erkennen und behandeln

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb, Entwickler
|Log-Level |*FATAL*
|Kategorie |*FATAL*
|Beschreibung a|
Schwerwiegende Fehler, von denen sich die Anwendung nicht erholen kann und beendet werden muss ("Unrecoverable Error"), müssen umgehend erkannt werden.
Zu diesem Zweck überwacht das betriebliche Monitoring das Log-Level FATAL und alarmiert den Betrieb bei jedem neuen Eintrag.

Logeinträge im Level FATAL signalisieren, dass der Systembetrieb unterbrochen ist und der Betrieb schnellstmöglich aktiv werden muss, um die Fehlerursache mit Hilfe der bereitgestellten Informationen zu analysieren, zu beheben und die Anwendung wieder neu zu starten.

Falls der Betrieb im Rahmen der Fehleranalyse feststellt, dass die Exception auf einen Fehler in der Anwendung zurückzuführen ist, wird der Logeintrag zur Fehleranalyse an die Entwickler übergeben.

Beispiele:

* `OutOfMemoryError`
* `StackOverflowError`
|====

[[beeinträchtigung-des-betriebs-erkennen-und-behandeln]]
=== Beeinträchtigung des Betriebs erkennen und behandeln

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb, Entwickler
|Log-Level |*ERROR*
|Kategorie |*ERROR*
|Beschreibung a|
Beeinträchtigungen des Systembetriebs (bspw.
Netzwerkverbindung kann nicht aufgebaut werden), müssen umgehend erkannt werden.
Zu diesem Zweck überwacht das betriebliche Monitoring das Log-Level ERROR und alarmiert den Betrieb bei jedem neuen Eintrag.

Logeinträge im Level ERROR signalisieren, dass der Fehler durch die Anwendung behandelt wurde und die Anwendung weiterläuft.
Der Betrieb muss jedoch schnellstmöglich aktiv werden, um die Fehlerursache mit Hilfe der bereitgestellten Informationen
zu analysieren, zu beheben und damit ein erneutes Auftreten des Fehlers zu verhindern.

Falls der Betrieb im Rahmen der Fehleranalyse feststellt, dass die Exception auf einen Fehler in der Anwendung
zurückzuführen ist, wird der Logeintrag zur Fehleranalyse an die Entwickler übergeben.

Beispiele:

* Fehler bei Netzwerkverbindung
* Datenbankverbindung konnte nicht aufgebaut werden
|====


[[unerwartetes-systemverhalten-erkennen-und-behandeln]]
=== Unerwartetes Systemverhalten erkennen und behandeln

[cols="1s,4",options="header"]
|====
|Akteur |Entwickler
|Log-Level |*WARN*
|Kategorie |*WARN*
|Beschreibung a|
Unerwartetes Systemverhalten muss umgehend erkannt werden.
Zu diesem Zweck überwacht das betriebliche Monitoring das Log-Level WARN.
Die entsprechenden Logeinträge werden an die Entwicklungsabteilung zur Analyse des Verhaltens und Identifikation notwendiger Maßnahmen übergeben.

Logeinträge im Level WARN signalisieren, dass der Fehler den Systembetrieb (wahrscheinlich) nicht beeinträchtigt.
Die bereitgestellten Informationen richten sich an die Entwickler.
Der Betrieb muss im Hinblick auf die Fehleranalyse hierbei zunächst nicht aktiv werden.

Beispiele:

* Inkonsistenzen im Datenbestand
* `IllegalArgumentException`
|====

[[betriebliche-ueberwachung]]
=== Betriebliche Überwachung

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb
|Log-Level |*INFO*
|Kategorie |*METRIK*
|Beschreibung a|
Logeinträge können dazu verwendet werden, Statistiken zu ermitteln, um eine betriebliche Überwachung des Systems zu realisieren.

Die folgenden Auswertungen werden dazu durchgeführt:

* Ermittlung der Anzahl der Aufrufe eines Services innerhalb der letzten Minute.
* Ermittlung der Anzahl der Aufrufe eines Services, die einen Fehler erzeugt haben, innerhalb der letzten Minute.
* Ermittlung der Durchschnittsdauer der letzten Aufrufe eines Services.
* Ermittlung des Zeitpunkts, wann die letzte Prüfung des Systems durchgeführt wurde und wann die letzte Prüfung
erfolgreich war.
Detaillierte Informationen zur Systemprüfung und der zu erstellenden Logeinträge ist in <<UeberwachungKonfigKonzept>> beschrieben.
|====

[[performance-ueberwachen]]
=== Performance überwachen

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb
|Log-Level |*INFO*
|Kategorie |*PROFIL*
|Beschreibung a|
„Performance-Analyse“ meint die Analyse von Laufzeiten an bestimmten kritischen Stellen der Anwendungslandschaft (bspw.
an Service-Methoden) und insbesondere deren Entwicklung über die Zeit.
Dies wird durchgeführt, um

* Engpässe zu erkennen, bspw.
wenn Aufrufe einer Komponente zunehmend länger dauern.
* Auswirkung einer Änderung auf die Performance zu bewerten, bspw.
um Laufzeiten vor und nach einer Aktualisierung der Datenbank zu vergleichen.
|====

[[nutzungshaeufigkeit-auswerten]]
=== Nutzungshäufigkeit auswerten

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb
|Log-Level |*INFO*
|Kategorie |*METRIK*
|Beschreibung a|
Die Analyse der Nutzungshäufigkeit bestimmter kritischer Stellen der Anwendungslandschaft (bspw.
von Service-Methoden oder Komponenten) und insbesondere deren Entwicklung über die Zeit wird zu folgenden Zwecken durchgeführt:

* Anomalien in Nutzung erkennen: Durch die betriebliche Überwachung der Nutzungshäufigkeit von Systemen können Ausreißer
 im Nutzerverhalten erkannt werden, die ggf.
ein Fehlverhalten des Aufrufers (bspw.
große Anzahl an Aufrufen weil Testsystem auf Produktivumgebung gelenkt ist) oder gar auf einen Missbrauchsversuch (Vielzahl
unautorisierter Zugriffe, um Benutzerdaten zu erraten) hindeuten.
* Auswirkung von Änderungen prognostizieren: Es kann bspw. überprüft werden, wie oft eine alte Schnittstelle noch verwendet
 wird und ob (bzw.
mit welchem Aufwand) dieses abgeschaltet werden kann.
* Auswirkung von Änderungen analysieren: Es kann bspw. überprüft werden, ob eine Erhöhung der Cache-Größe zur gewünschten
Reduktion der Nachbarsystemaufrufe geführt hat.
|====



[[systemzustand-und--ereignisse-überwachen]]
=== Systemzustand und -ereignisse überwachen

[cols="1s,4",options="header"]
|====
|Akteur |Betrieb
|Log-Level |*INFO*
|Kategorie |*JOURNAL*
|Beschreibung a|
Die Analyse des Systemzustands und der Systemereignisse umfasst bspw.
die Analyse, welche Version sich mit welcher Konfiguration in Betrieb befand, welche Änderungen vorgenommen wurden,
ob die Anwendung gestartet oder beendet wurde etc.

Diese Analyse wird querschnittlich zur Unterstützung der anderen Analysen durchgeführt, um bspw.
Fehler auf Änderungen des Systemzustands zurückzuführen, oder Performance-Schwankungen zu erklären.
|====

[[verarbeitung-eines-aufrufs-in-anwendungslandschaft-nachvollziehen]]
=== Verarbeitung eines Aufrufs in Anwendungslandschaft nachvollziehen

[cols="1s,4",options="header"]
|====
|Akteur |Entwickler
|Log-Level |*INFO*
|Kategorie |*JOURNAL*
|Beschreibung a|
Das Nachvollziehen, durch welche Systeme ein Aufruf der Anwendungslandschaft verarbeitet und weitergeleitet wurde
(die Korrelation der Logs zu einem Aufruf aus verschiedenen Systemen), dient den folgenden Zwecken:

* Unterstützung der Fehleranalyse, falls die systeminternen Logeinträge nicht ausreichend sind, bspw.
weil der Fehler durch ein aufrufendes System verursacht wurde.
* Nachvollziehen der Auswirkung eines Fehlers, um bspw.
erkennen zu können, ob durch den Aufruf in einem anderen System bereits Daten verändert wurden, die zurückgesetzt werden müssen.
|====

[[fachliche-verarbeitung-eines-aufrufs-nachvollziehen]]
=== Fachliche Verarbeitung eines Aufrufs nachvollziehen

[cols="1s,4",options="header"]
|====
|Akteur |Fachbereich
|Log-Level |*INFO*
|Kategorie |*JOURNAL*
|Beschreibung a|
Der Fachbereich kann die Anforderung an ein System stellen, dass die fachliche Verarbeitung eines Aufrufs
über das Logging nachvollziehbar sein muss.

Hierzu werden an definierten Stellen in der Anwendung spezifische Logeinträge erstellt – bspw.
beim Start oder Beenden eines Anwendungsfalls, beim Aufruf einer Anwendungsfunktion etc.

Die Anforderungen an das Logging sowie die Auswertung der Logeinträge sind spezifisch für das jeweilige System
und müssen mit dem Fachbereich abgestimmt werden.
|====

[[fehleranalyse-debugging]]
=== Fehleranalyse (Debugging)

[cols="1s,4",options="header"]
|====
|Akteur |Entwickler
|Log-Level |*DEBUG, TRACE*
|Kategorie |*DEBUG*
|Beschreibung |Die Fehleranalyse ist das „klassische“ Szenario der Log-Auswertung.
Hierbei werden detaillierte Debug-Informationen analysiert, um die Ursache eines Fehlers im Programmcode zu
finden und diesen zu beheben.
|====

[[logszenarien]]
== Logszenarien

In diesem Abschnitt werden die verschiedenen Logszenarien beschrieben, die definieren, _wann_ _welche_ Logeinträge
zu erstellen sind, um die im vorhergehenden Abschnitt definierten Auswertungen zu ermöglichen.

Die Bibliothek `isy-logging` stellt bereits einige Mechanismen bereit, durch die die notwendigen Logeinträge für einzelne
Auswertungen querschnittlich und rein konfigurativ umgesetzt werden können.
Diese sind in <<konfiguration-1>> beschrieben.

Logeinträge die individuell in bei der Anwendungsentwicklung zu erstellen sind, sind in <<anwendungsentwicklung>> beschrieben.

Wichtig ist, dass bei der Umsetzung einer Anwendung _keine_ Logeinträge erstellt werden, zu denen es _kein_ Szenario gibt – oder umgekehrt: sollte es sinnvoll sein einen Logeintrag zu erstellen, dann muss dafür auch ein Szenario definiert werden.

Die Szenarien sind nach folgendem Schema aufgebaut:

[cols="1s,3"]
|====
|Beschreibung |_Beschreibung der Situation innerhalb einer Anwendung._
|Logging |_Das durchzuführende Logging._
|Auswertungs-szenario |_Die Auswertungen, für die die erstellten Logeinträge verwendet werden._
|====

[[vorgaben-fuer-alle-logszenarien]]
=== Vorgaben für alle Logszenarien

Die folgenden Regeln sind für alle Logeinträge zu beachten:

1.  **Keine Binärdaten loggen**: Binärdaten sind nur schwer auswertbar und führen potentiell zu sehr langen Einträgen.
Logeinträge größer 64 KByte führen zu Fehlern bei der weiteren Verarbeitung.
Binärdaten dürfen daher nicht gelogged werden.
2.  **Größe der Parameter beschränken**: Beim Loggen der Schnittstellenkommunikation können durch große Objektstrukturen ebenfalls sehr große Logeinträge entstehen.
Das Loggen von Parametern kann durch entsprechende Konfiguration auf eine Maximalgröße beschränkt werden.

[[konfiguration-1]]
=== Konfiguration

Die folgenden Szenarien können rein konfigurativ umgesetzt werden, mit Mitteln, die durch `isy-logging` bereitgestellt
werden.
Sollte einer dieser Mechanismen in einer Anwendung nicht umgesetzt werden können (bspw.
weil die Anwendung nur Teile der IsyFact einsetzt und bspw.
Spring nicht verwendet), müssen die entsprechenden Einträge explizit durch Aufruf des Logging-Frameworks erstellt werden.

[[aufruf-an-systemgrenze]]
==== Aufruf an Systemgrenze

[cols="1s,3"]
|====
|Beschreibung |Es wird eine Außenschnittstelle des Systems – Service, GUI-Controller oder Batch – aufgerufen
(eingehender Aufruf).
|Logging |Der Aufruf der Methode wird mit Hilfe des `LogInterceptor` geloggt.
Dieser muss gemäß <<loggingmethodinterceptor>> für alle Außenschnittstellen des Systems konfiguriert sein.
|Auswertungs-szenario a|
* Performance analysieren
* Nutzungshäufigkeit analysieren
* Verarbeitung eines Aufrufs in Anwendungslandschaft nachvollziehen
* Betriebliche Überwachung
|====

[[rueckliefern-einer-exception-an-systemgrenze]]
==== Rückliefern einer Exception an Systemgrenze

[cols="1s,3"]
|====
|Beschreibung |Beim Aufruf eines Systems ist ein Fehler aufgetreten.
Es wird eine Exception an den Aufrufer zurückgegeben.
|Logging |Es müssen die übermittelten Eingabeparameter mit Hilfe des `LogInterceptor` geloggt werden.
Dieser muss gemäß <<loggingmethodinterceptor>> für alle Außenschnittstellen des Systems konfiguriert sein.
|Auswertungs-szenario a|
* Fehleranalyse (Debugging)
|====

[[aufruf-an-komponentengrenze]]
==== Aufruf an Komponentengrenze

[cols="1s,3"]
|====
|Beschreibung |Es wird eine Methode einer Komponentenschnittstelle im Anwendungskern aufgerufen (eingehender Aufruf).
|Logging a|
Das Loggen von Aufrufen an Komponentengrenzen liefert insbesondere für die Performanceanalyse wichtige Informationen,
führt jedoch in den meisten Anwendungen zu einem sehr hohen Logvolumen.

Jede Anwendung muss den LogInterceptor gemäß <<loggingmethodinterceptor>> konfigurieren, so dass das Logging an
den Komponentengrenzen bei Bedarf aktiviert werden kann.

|Auswertungs-szenario a|
* Performance überwachen
* Nutzungshäufigkeit analysieren
* Verarbeitung eines Aufrufs in Anwendungslandschaft nachvollziehen
|====

[[aufruf-eines-daos]]
==== Aufruf eines DAOs

[cols="1s,3"]
|====
|Beschreibung |Es wird eine Methode eines DAOs aufgerufen (eingehender Aufruf).
|Logging |Der Aufruf der Methode wird mit Hilfe des `LogInterceptor` geloggt.
Dieser muss gemäß <<loggingmethodinterceptor>> für alle Komponentenschnittstellen konfiguriert sein.
|Auswertungs-szenario a|
* Performance überwachen
* Nutzungshäufigkeit analysieren
* Verarbeitung eines Aufrufs in Anwendungslandschaft nachvollziehen
|====

[[aufruf-eines-nachbarsystems]]
==== Aufruf eines Nachbarsystems

[cols="1s,3"]
|====
|Beschreibung |Es wird ein entfernter Service eines Nachbarsystems aufgerufen.
|Logging |Der Aufruf der Methode wird mit Hilfe des `LogInterceptor` geloggt.
Dazu muss in der aufrufenden Klasse gemäß <<loggingmethodinterceptor-und-loggingmethodinvoker>> eine
Instanz der Klasse erstellt und das Remote-Interface des Nachbarsystem mit Hilfe der Methode `rufeNachbarsystemAuf`
aufgerufen werden.
Dies wird bereits durch die Erweiterung der HTTP-Invoker-Implementierung (IsyHttpInvokerProxyFactoryBean) des
Bausteins Service umgesetzt (siehe <<ServiceDetailkonzept>>), so dass hierfür keine Anpassung notwendig ist.
Bei Nachbarsystemen, die selbst kein IsyFact-konformes Logging umsetzen (Drittsoftware wie bspw.
ein Suchverfahren), kann es notwendig sein, zusätzliche Informationen in der aufrufenden Anwendung zu loggen.
Entsprechende Vorgaben werden in den Nutzungskonzepten der jeweiligen Bausteine definiert.
|Auswertungs-szenario a|
* Nutzungshäufigkeit analysieren
* Verarbeitung eines Aufrufs in Anwendungslandschaft nachvollziehen
* _Weitere systemspezifische Auswertungen_
|====

[[hochfahren-herunterfahren]]
==== Hochfahren / Herunterfahren

[cols="1s,3"]
|====
|Beschreibung |Ein Anwendungssystem oder ein Batch wird gestartet oder beendet.
|Logging |Der Vorgang wird durch den `LogApplicationListener` geloggt.
Dieser muss gemäß <<LogApplicationListener>> konfiguriert sein.
|Auswertungs-szenario a|
* Systemzustand und -ereignisse überwachen
|====

[[neueinlesen-eines-geänderten-konfigurationsparameters]]
==== Neueinlesen eines geänderten Konfigurationsparameters

[cols="1s,3"]
|====
|Beschreibung |Es wird festgestellt, dass sich ein Konfigurationsparameter der betrieblichen Konfiguration
oder eine Laufzeitkonfiguration geändert hat.
Der geänderte Wert wird im laufenden Betrieb übernommen.
|Logging a|
Es muss ein Logeintrag erstellt werden, der die Änderung des Konfigurationsparameters dokumentiert:

`log.info("Der Konfigurationsparameter <Parameter> wurde geändert von <Alter Wert> auf <Neuer Wert>",
<Name des Parameters>, <Alter Wert>, <Neuer Wert>)`

Dies wird durch die Klasse `ReloadablePropertyKonfiguration` der Bibliothek isy-konfiguration bereits umgesetzt,
so dass bei deren Verwendung hierfür nichts mehr zu tun ist.
|Auswertungs-szenario a|
* Systemzustand und -ereignisse überwachen
|====

[[loggen-der-schnittstellenkommunikation]]
==== Loggen der Schnittstellenkommunikation

[cols="1s,3"]
|====
|Beschreibung a|
In Ausnahmefällen kann es notwendig sein, Teile oder die gesamten Daten, die über eine Schnittstelle
ausgetauscht werden, zu loggen.
Dies ist insbesondere dann der Fall, wenn:

* Es sich um eine technisch sehr komplexe oder proprietäre Schnittstelle handelt.
* Ein „unerklärliches“ Verhalten im Systembetrieb festgestellt wurde, welches mit den Standard Debug-Ausgaben
nicht nachvollzogen  werden kann.
|Logging a|
Das Erstellen der Logeinträge erfolgt mittels des LogInterceptors der bereits für die Szenarien
in <<schwerwiegenden-fehler-erkennen-und-behandeln>> und
<<beeinträchtigung-des-betriebs-erkennen-und-behandeln>> konfiguriert wurde.

Zur Ausgabe der Schnittstellenkommunikation muss der Schalter loggeDaten auf true gesetzt werden
(<<loggingmethodinterceptor>>).

|Auswertungs-szenario a|
* Fehleranalyse (Debugging)
|====

[[anwendungsentwicklung]]
=== Anwendungsentwicklung

In diesem Abschnitt sind alle Szenarien beschrieben, bei denen Logeinträge im Anwendungscode explizit
durch den Entwickler vorzusehen sind.

Wenn durch ein Logszenario ein Eintrag im Level INFO gefordert ist, muss ein entsprechender
Ereignisschlüssel definiert werden – dies ist in <<ereignisschluessel>> beschrieben.
Die definierten Schlüssel müssen im Systementwurf dokumentiert werden – analog
zu <<ereignisschluessel-isy-logging>> dieses Dokuments.

[[behandlung-einer-exception]]
==== Behandlung einer Exception

[cols="1s,3"]
|====
|Beschreibung a|
Es wird eine Exception gefangen und behandelt.

Wichtig: Exceptions werden nur geloggt, wenn Sie auch behandelt werden.
Wird eine Exception nicht behandelt (also an den Aufrufer weitergereicht), wird sie auch nicht geloggt.

|Logging a|
Je nach Schwere des Fehlers wird die Exception in einem der folgenden Log-Level geloggt (siehe <<log-level>>):

* FATAL: Falls es sich um einen schwerwiegenden Fehler handelt (vgl.
auch Szenario „Schwerwiegenden Fehler erkennen und behandeln“ in <<schwerwiegenden-fehler-erkennen-und-behandeln>>).
* ERROR: Falls der Fehler zur Beeinträchtigung des Systembetriebs führt, das System aber weiterlaufen kann (vgl.
auch Szenario „Beeinträchtigung des Betriebs erkennen und behandeln“ in
<<beeinträchtigung-des-betriebs-erkennen-und-behandeln>>)
* WARN: Wenn es sich um ein inkonsistentes / unerwartetes Systemverhalten handelt, welches der Entwicklungsabteilung mitgeteilt werden muss (vgl.
auch Szenario „Unerwartetes Systemverhalten erkennen und behandeln“ in
<<unerwartetes-systemverhalten-erkennen-und-behandeln>>).
* INFO: Wenn es sich um einen „erwarteten“ Fehler handelt, der durch das System behandelt werden.
Dies umfasst insbesondere auch Exceptions, die mit einem Retry behandelt werden – bspw.
wenn eine OptimisticLockException gefangen und die Anfrage wiederholt wird.

Das Erstellen der Logeinträge erfolgt mittels der Methoden `log.fatal(…)`, `log.error(…)`, `log.warn(…)` und
`log.info(…)`. Sollte es zwingend notwendig sein, datenschutzrelevante fachliche Daten in den Logeintrag zu schreiben, muss stattdessen die entsprechende Methode zum Loggen von Fachdaten verwendet werden (vgl.
<<konzeptlogging>>): `log.fatalFachdaten(…)`, `log.errorFachdaten(…)` und `log.warnFachdaten(…)`.

Die Lognachricht muss das eingetretene Szenario kurz und möglichst Präzise beschreiben, bspw.: „Fehler beim Zugriff auf die Datenbank“.

[underline]#Anmerkung#: Zur Fehleranalyse sind insbesondere der Fehlerschlüssel, Fehlertext und der Stacktrace relevant.
Diese werden automatisch durch das Logging-Framework geloggt und müssen daher nicht manuell
in die Lognachricht übernommen werden.
|Auswertungs-szenario a|
* Schwerwiegenden Fehler erkennen und behandeln
* Beeinträchtigung des Betriebs erkennen und behandeln
* Unerwartetes Systemverhalten erkennen und behandeln
|====

[[wichtige-systemereignisse]]
==== Wichtige Systemereignisse

[cols="1s,3"]
|====
|Beschreibung a|
Es tritt ein wichtiges Ereignis auf, welches für die Durchführung der folgenden Auswertungen relevant ist:

* Betriebliche Überwachung
* Performance überwachen
* Nutzungshäufigkeit auswerten
* Systemzustand und -ereignisse überwachen

Es ist Aufgabe des technischen Chefdesigners diese Stellen im Rahmen des Systementwurfs zu Identifizieren und mit dem Auftraggeber abzustimmen.

|Logging a|
Es muss ein spezifischer Ereignisschlüssel definiert, im Systementwurf dokumentiert und ein Logeintrag im Level INFO erstellt werden.
Tritt an mehreren Stellen in der Anwendung das gleiche zu loggende Ereignis auf, kann der gleiche Ereignisschlüssel verwendet werden. +
Das Loggen der Einträge erfolgt mit der Methode +
`log.info(<kategorie>, <schluessel>, <nachricht>, <werte>)` +
Bspw.: +
`log.info(LogKategorie.JOURNAL, "SYSXY01234", "Das Sucherfahren lieferte einen Datensatz mit ID {}.
Dieser ist nicht im Bestand vorhanden und wird im Suchverfahren gelöscht.", "12345");` +
`log.info(LogKategorie.SICHERHEIT, "SYSXY01235", "Innerhalb der letzten Minute wurden {}
ungültige Logins mit Anwendernamen {} durchgeführt.", "29", "max_muster");`
|Auswertungs-szenario a|
* Betriebliche Überwachung
* Performance überwachen
* Nutzungshäufigkeit auswerten
* Systemzustand und -ereignisse überwachen
|====

[[durchführen-einer-bulk-query]]
==== Durchführen einer Bulk-Query

[cols="1s,3"]
|====
|Beschreibung |Es wird eine native SQL-Bulk-Query (Manipulation mehrerer Datensätze) in der Datenbank durchgeführt.
|Logging a|
Es muss ein Logeintrag erstellt werden, der die Query beschreibt und die Anzahl der betroffenen
Datensätze als Platzhalter enthält: +
`log.debug("<Beschreibung der Query mit Platzhalter für Anzahl der betroffenen Datensätze und Name der Query>",
<Name der Query>, <Anzahl Datensätze>);` +
Bspw.: +
`log.debug("Query \{} zum Löschen veralteter Sachverhalte wurde ausgeführt.
Es wurden \{} Sachverhalte gelöscht.", <Name der Query>, <Anzahl Datensätze>);`
|Auswertungs-szenario a|
* Fehleranalyse
|====

[[unterstützung-der-fehleranalyse-debug]]
==== Unterstützung der Fehleranalyse (Debug)

[cols="1s,3"]
|====
|Beschreibung a|
An allen Stellen der Verarbeitungslogik, die für eine spätere Fehleranalyse _relevant_ sind, müssen entsprechende DEBUG-Einträge erstellt werden.
Welche Stellen relevant sind, ist abhängig vom konkreten System und kann nicht allgemein festgelegt werden.
Es liegt im Ermessen des Technischen Chefdesigners und der Entwickler, diese Stellen zu identifizieren.
Typische Szenarien sind:

* Unterschiedliche Zweige in `if-then-else` Anweisungen.
* Passieren kritischer Verarbeitungsschritte bspw.
dem Abschluss der Prüfung übermittelter Daten.
|Logging a|
Das Erstellen der Logeinträge erfolgt mittels der Methode: +
`log.debug("<Nachricht>", "<Werte>");` +
Sollte es zwingend notwendig sein, fachliche, datenschutzrelevante Daten in den Logeintrag zu schreiben, muss stattdessen die Methode +
`log.debugFachdaten("<Nachricht>", "<Werte>");` +
verwendet werden (vgl. <<konzeptlogging>>). +
Da dieses Szenario eine Vielzahl unterschiedlicher Fälle zusammenfasst, können hierfür keine konkreten Nachrichten
vorformuliert werden.
Zu beachten ist, dass die Nachrichten primär durch Entwickler im Falle eines Fehlers ausgewertet werden, meist
aber nicht dem Entwickler, der den Code geschrieben hat. +
Die jeweilige Nachricht *muss* daher *zwingend* so formuliert werden, dass das Ereignis auch ohne Kenntnis des
Quellcodes verstanden werden kann – analog zu den in <<fachliche-korrelation-von-eintraegen>> definierten Lognachrichten.
Bspw.:

* *Falsch*: „Hier“, „Fertig“, „1“, „OK“
* *Richtig*: „Regelwerksprüfungen erfolgreich abgeschlossen“, „Führe Suche nach Personen durch“

[underline]#Anmerkung#: Für eine detaillierte Fehleranalyse ist es natürlich meist unerlässlich auch den Programmcode
einzusehen.
Durch die verständliche Formulierung der Logeinträge kann der Hergang, der zu einem Fehler geführt hat, jedoch viel
einfacher und schneller nachvollzogen werden und damit die Fehlerquelle schneller identifiziert werden.
|Auswertungs-szenario a|
* Fehleranalyse (Debugging)
|====

[[fachliche-korrelation-von-eintraegen]]
==== Fachliche Korrelation von Einträgen

[cols="1s,3"]
|====
|Beschreibung a|
In komplexen Verfahren kann es notwendig sein, die erstellten Logeinträge fachlich in Verbindung zueinander zu
setzen – bspw.
Kennzeichnen aller Logeinträge, die sich auf einen bestimmten Datensatz beziehen, durch Aufnahme des
eindeutigen Schlüssel des betroffenen Datensatzes.

Wenn diese Anforderung gegeben ist, kann dies beim Aufruf an der Systemgrenze (vgl.
Szenario <<aufruf-an-systemgrenze>> __Aufruf an Systemgrenze__) wie im Folgenden beschrieben berücksichtigt werden.
|Logging a|
An der Systemgrenze wird der eindeutige Schlüssel des Datensatzes in den MDC aufgenommen.
Dabei müssen folgende Aspekte berücksichtigt werden:

* Das Setzen und Entfernen des Schlüssels im MDC erfolgt direkt über die Klasse „MDC“, die von SLF4J bereitgestellt wird.
* Der MDC ist eine Map (Mapped Diagnostic Context - Name-Wert-Paar). Als Name muss ein sprechender, gut auswertbarer Name verwendet werden bspw. „kundennummer“.
* Sollte es sich bei dem Schlüssel um datenschutzrelevante Daten handeln, muss der MDC mit einem Marker als „fachlich“ gekennzeichnet werden (vgl.
<<mdchelper>>).
* Der Schlüssel und der ggf.
gesetzte Marker müssen in jedem Fall beim Verlassen der Methode, in der sie gesetzt wurden, wieder aus dem MDC entfernt werden.
Das Entfernen sollte daher in einem „finally“-Block stattfinden.
|Auswertungs-szenario a|
* Fachliche Verarbeitung eines Aufrufs nachvollziehen
* Fehleranalyse (Debugging)
|====

[[loggen-fachlicher-operationen]]
==== Loggen fachlicher Operationen

[cols="1s,3"]
|====
|Beschreibung |Der Fachbereich hat für das System Anforderungen definiert, dass die Verarbeitung einzelner
Aufrufe fachlich nachvollziehbar sein muss.
Dies ist im Auswertungsszenario „Fachliche Verarbeitung eines Aufrufs nachvollziehen“
(siehe <<fachliche-verarbeitung-eines-aufrufs-nachvollziehen>>) beschrieben.
|Logging |Die zu erstellenden Logeinträge sind spezifisch für das jeweilige Verfahren.
Zu beachten ist jedoch, dass die Aufrufe im Log-Level INFO zu erstellen sind.
Für alle Logeinträge, die dem gleichen Zweck dienen (also der gleichen fachlichen Anforderung), muss der
gleiche Ereignisschlüssel verwendet werden.
|Auswertungs-szenario a|
* Fachliche Verarbeitung eines Aufrufs nachvollziehen
* Fehleranalyse (Debugging)
|====

[[ereignisschluessel-isy-logging]]
= Ereignisschlüssel isy-logging

Im Folgenden werden die spezifischen Ereignisschlüssel der Komponente `isy-logging` beschrieben:

:desc-table-ESisylog: Ereignisschlüssel isy-logging
[id="table-ESisylog",reftext="{table-caption} {counter:tables}"]
.{desc-table-ESisylog}
[cols="<6m,^2,<3,<9",options="header"]
|====
|Schlüssel (s.u.) |Level |Kategorie |Text
a|
`EISYLO01001`
(`EPLILO01001`)
 |INFO |JOURNAL |Methode <Klasse.Methode> wird aufgerufen.
a|
`EISYLO01002`
(`EPLILO01002`)
 |INFO |METRIK |Aufruf von <Klasse.
Methode> erfolgreich beendet.
a|
`EISYLO01003`
(`EPLILO01003`)
 |INFO |METRIK |Aufruf von <Klasse.
Methode> mit Fehler beendet.
a|
`EISYLO01004`
(`EPLILO01004`)
 |INFO |PROFILING |Aufruf von <Klasse.
Methode> erfolgreich beendet.
Der Aufruf dauerte <Dauer in Millisekunden> ms.
a|
`EISYLO01005`
(`EPLILO01005`)
 |INFO |PROFILING |Aufruf von <Klasse.
Methode> mit Fehler beendet.
Der Aufruf dauerte <Dauer in Millisekunden> ms.
a|
`EISYLO01011`
(`EPLILO01011`)
 |INFO |JOURNAL |Die Methode <Klasse.Methode> des Nachbarssystems <systemname> wird unter der URL <url> aufgerufen.
a|
`EISYLO01012`
(`EPLILO01012`)
 |INFO |METRIK |Aufruf von <Klasse.
Methode> des Nachbarssystems <systemname> unter der URL <url> erfolgreich beendet.
a|
`EISYLO01013`
(`EPLILO01013`)
 |INFO |METRIK |Aufruf von <Klasse.
Methode> des Nachbarssystems <systemname> unter der URL <url> mit Fehler beendet.
a|
`EISYLO01014`
(`EPLILO01014`)
 |INFO |PROFILING |Aufruf von <Klasse.
Methode> des Nachbarssystems <systemname> unter der URL <url> erfolgreich beendet.
Der Aufruf dauerte <Dauer in Millisekunden> ms.
a|
`EISYLO01015`
(`EPLILO01015`)
 |INFO |PROFILING |Aufruf von <Klasse.
Methode> des Nachbarssystems <systemname> unter der URL <url> mit Fehler beendet.
Der Aufruf dauerte <Dauer in Millisekunden> ms.
a|
`EISYLO02001`
(`EPLILO02001`)
 |INFO |JOURNAL |ApplicationContext des Systems <Systemname> (Systemart) wurde gestartet oder aktualisiert.
a|
`EISYLO02002`
(`EPLILO02002`)
 |INFO |JOURNAL |Der ApplicationContext des Systems <Systemname> (Systemart) wurde gestopped.
a|
`EISYLO02003`
(`EPLILO02003`)
 |INFO |JOURNAL |Die Systemversion ist <Versionsnummer>.
a|
`EISYLO02004`
(`EPLILO02004`)
 |INFO |JOURNAL |Der Laufzeitparameter <Parametername> besitzt den Wert <Wert>.
|====

[NOTE]
====
Bis zur Version 1.0.7 von `isy-logging` wurde `EPLILO` als Präfix der Schlüssel verwendet. Diese alten
Ereignisschlüssel sind jeweils in Klammer angegeben.
====
